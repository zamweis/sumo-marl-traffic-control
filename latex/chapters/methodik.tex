
\section{Methodik}

\subsection{Untersuchungsregion und Datenbasis}

\subsubsection{Auswahl der Untersuchungsregion}

Für die Anwendung und Evaluation der KI-basierten Verkehrssteuerung wurde ein Ausschnitt des innerstädtischen Straßennetzes von Karlsruhe gewählt. Die Auswahl fiel auf ein Gebiet rund um die Reinhold-Frank-Straße und das Mühlburger Tor, das durch hohe Verkehrsdichte, komplexe Knotenpunkte und mehrere signalgesteuerte Kreuzungen gekennzeichnet ist. Der gewählte Bereich liegt geografisch zwischen 49{,}006947\,\textdegree{}N und 49{,}015602\,\textdegree{}N sowie 8{,}380176\,\textdegree{}E und 8{,}403887\,\textdegree{}E und deckt mehrere stark frequentierte Hauptachsen ab.

Die Entscheidung für diese Region basiert auf folgenden Kriterien:

\begin{itemize}
  \item \textbf{Hohe Verkehrsbedeutung:} Das Gebiet stellt einen wichtigen innerstädtischen Verkehrsraum dar, der sowohl Pendlerverkehr als auch lokalen Individualverkehr aufnimmt.
  \item \textbf{Bekanntes Stauaufkommen:} Die Reinhold-Frank-Straße ist in der Stadtbevölkerung für regelmäßige Verkehrsstaus bekannt, insbesondere zu Stoßzeiten.
  \item \textbf{Verfügbarkeit realer Verkehrszähldaten:} Eine automatische Dauerzählstelle erhebt dort täglich Verkehrsdaten. Für den Zeitraum vom 1.1. bis 20.6.2025 wurden durchschnittlich 21.300 Kfz/Tag erfasst.
  \item \textbf{Zusätzliche Zähldaten angrenzender Hauptverkehrsstraßen:} Zählstellen an der B10, B36, L605 und in Durlach liefern ergänzende Werte zur Plausibilisierung des Gesamtverkehrsflusses.
  \item \textbf{Vorhandensein mehrerer Ampelanlagen:} Im Netz befinden sich 17 signalgesteuerte Kreuzungen, geeignet für RL-gesteuerte Steuerungsexperimente.
  \item \textbf{Gute Abgrenzbarkeit:} Das Gebiet ist topologisch geschlossen und in SUMO sauber simulierbar.
  \item \textbf{Verfügbarkeit von Geodaten:} Die Region ist in OpenStreetMap detailliert kartiert.
\end{itemize}

\subsubsection{Verfügbare Verkehrszähldaten}

Für die Kalibrierung und Validierung der Verkehrssimulation wurden verschiedene reale Zähldatenquellen aus dem Raum Karlsruhe herangezogen. Hauptquelle war dabei die offene Mobilitätsdatenplattform des Landes Baden-Württemberg (MobiData BW)\cite{mobidata_stunden}. Dort werden automatisiert erfasste Stundenwerte stationärer Dauerzählstellen veröffentlicht, die eine fein aufgelöste Analyse von Verkehrsverläufen ermöglichen.

Konkret wurden folgende Datensätze ausgewertet:

\begin{itemize}
  \item \textbf{Dauerzählstelle Reinhold-Frank-Straße:} Erfasst täglich die Anzahl der Kraftfahrzeuge (Kfz), aufgeschlüsselt nach Fahrzeugklassen (PKW, lNfz, sNfz). Für den Zeitraum 01.01.–20.06.2025 lag der durchschnittliche Tagesverkehr (DTV\footnote{DTV = durchschnittlicher Tagesverkehr: Durchschnittliche Anzahl an Fahrzeugen pro Tag über einen bestimmten Zeitraum hinweg.}) bei ca. 21.300 Kfz/Tag.

  \item \textbf{Historische Jahresmittelwerte:} Langzeitdatenreihen von 2008–2024 aus MobiData BW ermöglichen eine Kontextualisierung der aktuellen Verkehrsbelastung.

  \item \textbf{Zählstellen an äußeren Zufahrtsachsen:} Ergänzende Zähldaten aus dem Jahr 2023 an acht stark befahrenen Einfallstraßen (u.\,a. B10, B36, L605)\cite{mobidata_karte} liefern Anhaltspunkte zur Verkehrsstärke an den Netzrändern.
\end{itemize}

Die Kombination dieser Quellen ermöglicht eine robuste, datenbasierte Schätzung realistischer Flussverteilungen für die Simulation – sowohl zeitlich (z.\,B. Spitzenlasten) als auch räumlich (Zufahrtsverteilung).

\subsection{Aufbau des Simulationsmodells in SUMO}

\subsubsection{Netzgenerierung und Verkehrsflussmodellierung}

Zur Modellierung des realen Straßennetzes wurde ein Kartenausschnitt des Untersuchungsgebiets über die Exportfunktion von OpenStreetMap\cite{osm-export} heruntergeladen und anschließend mit JOSM\cite{josm} bearbeitet. Die Auswahl des Ausschnitts orientierte sich an der geografischen Abgrenzung rund um die Reinhold-Frank-Straße sowie die angrenzenden Hauptverkehrsachsen im Bereich des Mühlburger Tors. Der bereinigte Kartenausschnitt wurde anschließend mit dem SUMO-Werkzeug \texttt{netconvert}\cite{sumo-tools} in ein netzwerkkompatibles XML-Format überführt. Dabei kamen zusätzliche Optionen zur Verbesserung der Ampelmodellierung und Fahrstreifenzuordnung zum Einsatz (z.\,B. \texttt{--tls.guess-signals} und \texttt{--junctions.join}).

Die Erzeugung der Fahrzeugbewegungen erfolgte auf zwei Wegen: Zum einen wurden mit dem SUMO-Skript \texttt{randomTrips.py} initiale Testflüsse erzeugt, um die Simulation zu validieren. Zum anderen wurden auf Basis der analysierten Verkehrszähldaten realitätsnahe Flussprofile definiert, welche die beobachteten DTV-Werte auf die Randkanten des simulierten Netzes verteilen. Dabei wurde darauf geachtet, dass die Hauptverkehrsachsen wie die B10 oder B36 als primäre Zufahrtsrouten fungieren und mit einer höheren Fahrzeugdichte gewichtet werden.

Die resultierenden Routendateien wurden anschließend mit \texttt{duarouter} verarbeitet, um konfliktfreie Fahrten über das simulierte Netz zu erzeugen. Um unterschiedliche Verkehrssituationen abzubilden, wurden Szenarien mit variierender Verkehrsdichte simuliert – beispielsweise für Morgen- und Abendspitzen sowie für gleichmäßige Durchfahrtsverteilung.

Die erzeugten Flüsse orientieren sich dabei an der realen Kapazität der Knoten und Straßen und wurden mit Hilfe von Detektor-Ausgaben (u.\,a. \texttt{laneAreaDetector}) überprüft und bei Bedarf nachjustiert.

\subsubsection{Identifikation relevanter Zufahrtskanten}

Die Generierung realistischer Verkehrseinträge in das simulierte Netz basiert auf der systematischen Ermittlung geeigneter Zufahrtskanten. Diese stellen die äußeren Einfallstraßen dar, über die der Verkehr gemäß den Zähldaten in das Untersuchungsgebiet einfließt.

Zur Auswahl wurden zunächst bekannte Hauptverkehrsachsen wie die B10, B36, L605 oder die Durlacher Allee herangezogen. Anschließend erfolgte eine semiautomatische Zuordnung der SUMO-Kanten (\texttt{<edge>}) auf Basis der in OpenStreetMap vergebenen Straßennamen. Hierzu wurde ein Python-Skript eingesetzt, das alle Kanten mit einem \texttt{name}-Attribut durchsuchte und auf relevante Teilstrings prüfte (z.\,B. \texttt{"B10"}, \texttt{"Reinhold-Frank-Straße"}). Die Ergebnisse wurden manuell geprüft und bei Bedarf durch visuelle Kontrolle in \texttt{netedit} ergänzt.

Die so extrahierten Kanten wurden je Verkehrsachse gruppiert und bilden die Grundlage für die segmentierte Trip-Erzeugung.

\subsubsection{Automatisierte Generierung von Trips auf Basis realer Zählerdaten}

Zur Simulation realitätsnaher Verkehrsströme wurden die durchschnittlichen Tagesverkehre (DTV) aus Abschnitt~\ref{sec:zaehlstellen-karlsruhe} auf die jeweiligen Zufahrtsgruppen skaliert und anschließend auf die Simulationsdauer von 3600\,s verteilt. Ein eigens entwickeltes Python-Skript erzeugte aus diesen Daten Fahrzeugeinträge (\texttt{<trip>}), die mithilfe von \texttt{randomTrips.py} über die identifizierten Randkanten eingespielt wurden.

Die erzeugten Trips wurden im XML-Format gespeichert und anschließend mit \texttt{duarouter} zu vollständigen, konfliktfreien Routen (\texttt{<route>}) konvertiert. Die Gesamtanzahl und Verteilung der Fahrzeuge orientierte sich dabei an den stündlich extrapolierten DTV-Werten. Es wurde darauf geachtet, dass insbesondere stark belastete Zufahrten (z.\,B. B10, L605) mit höherem Gewicht berücksichtigt wurden.

\subsubsection{Visuelle und technische Validierung des Netzmodells}

Vor dem eigentlichen Einsatz des Modells wurde das gesamte Netz sowohl strukturell als auch funktional validiert. Die Prüfung erfolgte in mehreren Stufen:

\begin{itemize}
  \item \textbf{Netzprüfung:} Einsatz von \texttt{netconvert --check-lane-geometry} und \texttt{netcheck} zur Überprüfung der topologischen Konsistenz.
  \item \textbf{Visuelle Kontrolle:} Mit der SUMO-GUI sowie \texttt{netedit} wurden kritische Knoten visuell inspiziert, um Fehler wie unverbundene Spuren, widersprüchliche Geometrien oder falsche Richtungen zu identifizieren.
  \item \textbf{Manuelle Überprüfung aller TLS:} Jede einzelne Lichtsignalanlage wurde manuell in \texttt{netedit} geöffnet. Die Phasenpläne, gesteuerten Verbindungen und Zustandslängen (\texttt{state}) wurden dabei geprüft und bei Bedarf korrigiert.
\end{itemize}

Diese manuelle Validierung war äußerst zeitaufwändig, da fehlerhafte TLS nicht automatisch von SUMO erkannt werden. Die Identifikation von Problemen wie unpassenden \texttt{linkIndex}-Werten oder inkonsistenten Zustandslängen erforderte intensives Testen und systematisches Debugging. In mehreren Fällen mussten TLS-Definitionen komplett neu erstellt oder aufgelöst werden, was ein hohes Maß an Modellierungsverständnis und Geduld erforderte.

\subsubsection{Szenarien und Referenzsimulationen}

Zur Validierung der Verkehrsflüsse wurden unterschiedliche Simulationsszenarien implementiert:

\begin{itemize}
  \item \textbf{Morgenspitze (Rush Hour):} Verstärkte Einträge an den Süd- und Westzufahrten mit hoher Verkehrsdichte.
  \item \textbf{Abendliche Rückstaus:} Stärkere Belastung der Ausfallstraßen und des Innenstadtrings.
  \item \textbf{Gleichmäßiger Tagesverlauf:} Homogene Einträge mit ca. 1000 Fahrzeugen/h pro Richtung.
  \item \textbf{Zentrumsfokus:} Fokus auf Verkehrsströme über die Reinhold-Frank-Straße und das Mühlburger Tor.
\end{itemize}

Die resultierenden Simulationen dienten der Überprüfung der Netzdurchlässigkeit und der Validierung der physischen Kapazität der Kreuzungen. Dazu wurden Heatmaps, Fahrzeugzählungen sowie Detektor-Ausgaben (z.\,B. \texttt{laneAreaDetector}) ausgewertet. Die gewonnenen Erkenntnisse flossen in die finale Konfiguration der Flüsse und Phasenpläne ein.


\subsubsection{Signalsteuerung und Simulationsparameter}

Das untersuchte Verkehrsnetz umfasst insgesamt 17 signalgesteuerte Kreuzungen. Diese wurden aus dem OpenStreetMap-Datensatz automatisch erkannt und im Rahmen der Netzkonvertierung mit \texttt{netconvert} anhand der Option \texttt{--tls.guess-signals} initial als Lichtsignalanlagen (Traffic Light Systems, TLS) modelliert. Die generierten Ampelphasen wurden anschließend manuell überprüft und bei Bedarf über die mit SUMO mitgelieferte GUI \texttt{netedit} angepasst.

Für die initiale Simulation wurde eine feste Phasenlogik (fixed-time control) verwendet, um ein Grundverhalten zu etablieren. Dabei erhielten alle Kreuzungen definierte Signalphasen mit festen Umlaufzeiten zwischen 30 und 60 Sekunden, abhängig von der Knotentopologie. Zur Vorbereitung des Reinforcement-Learning-Trainings wurden alle relevanten Kreuzungen so konfiguriert, dass sie in SUMO als „aktuiert“ geschaltet werden konnten. Dies ist erforderlich, damit die Steuerung durch externe Agenten via \texttt{TraCI} möglich ist.

Die Simulation wurde mit folgenden Parametern durchgeführt:

\begin{itemize}
  \item \textbf{Simulationszeitraum:} 3600 Sekunden (entspricht 1 Stunde Echtzeit)
  \item \textbf{Zeitschritt (step-length):} 1,0 s
  \item \textbf{Routengenerierung:} deterministisch mit fixer seed zur Reproduzierbarkeit
  \item \textbf{Simulationstyp:} \texttt{meso}-Modus zur Beschleunigung des Trainings (später auch \texttt{default}-Modus für Evaluation)
  \item \textbf{Verkehrsverteilung:} über \texttt{flows.xml} definiert und über Randkanten eingeleitet
\end{itemize}

Die Definition und Verwaltung der TLS-Systeme erfolgt in separaten Dateien (\texttt{*.add.xml}), welche in der SUMO-Konfigurationsdatei eingebunden werden. Für die spätere Anbindung an das Reinforcement-Learning-Modul wurden alle zu steuernden Ampelanlagen mit eindeutigen IDs versehen und überprüft.

\subsection{Reinforcement-Learning-Konzept}
\subsubsection{Formulierung des RL-Problems}
Das Problem der Verkehrssteuerung wird als sequentielles Entscheidungsproblem modelliert und mit Hilfe von Reinforcement Learning (RL) gelöst. Ziel ist es, einen Agenten zu trainieren, der durch geeignete Steuerung der Ampelphasen den Verkehrsfluss optimiert. Die Umgebung besteht aus dem simulierten Straßennetz, wie es in SUMO definiert ist. Die Interaktion erfolgt über das TraCI-Interface, das eine Laufzeitsteuerung der Ampelanlagen erlaubt.
\paragraph{Zustände}

Der Zustand \( s_t \) eines Reinforcement-Learning-Agenten beschreibt die Verkehrssituation an einer einzelnen Kreuzung zum Zeitpunkt \( t \). Ziel ist es, dem Agenten ausreichend Informationen über den lokalen Verkehrsfluss zur Verfügung zu stellen, damit er fundierte Entscheidungen über die Steuerung der Lichtsignalanlage treffen kann.

Die Zustandsrepräsentation basiert auf den folgenden Komponenten:

\begin{itemize}
  \item \textbf{Fahrzeuganzahl pro Zufahrtsspur:} Für jede dem Knoten zuführende Fahrspur wird die aktuelle Anzahl an Fahrzeugen ermittelt. Dies geschieht über sogenannte \texttt{laneAreaDetector}, die für jede Spur individuell in SUMO definiert werden. Die Werte werden periodisch über \texttt{TraCI} abgefragt.

  \item \textbf{Warteschlangenlänge (queue length):} Gibt die Anzahl der Fahrzeuge an, die sich auf einer Spur mit Geschwindigkeit \texttt{< 0.1 m/s} befinden. Dies ist ein wichtiges Maß für Rückstaus an Kreuzungen.

  \item \textbf{Durchschnittliche Geschwindigkeit pro Spur:} Diese Kenngröße erlaubt Rückschlüsse auf den Verkehrsfluss pro Richtung und ergänzt die reine Anzahlinformation.

  \item \textbf{Ampelphase (TLS state):} Die aktuell geschaltete Ampelphase wird als diskrete Phase kodiert (z.\,B. 0, 1, 2, ...). In SUMO entspricht dies der Index der aktiven Phase im Phasenplan der TLS.

  \item \textbf{Dauer der aktuellen Phase:} Die Anzahl der Zeitschritte seit Beginn der aktuellen Phase. Diese Information ist notwendig, um Phasenlängen sinnvoll zu steuern (z.\,B. Mindestgrünzeit).

  \item \textbf{Binärmasken zur Phasenwechselbarkeit:} Kodierung, ob ein Wechsel zur nächsten Phase gemäß Übergangsbedingungen (z.\,B. Mindestgrünzeit) aktuell möglich ist. Diese Information ist erforderlich, falls das Aktionsmodell auch direkte Sprünge zwischen nicht direkt benachbarten Phasen erlaubt.

  \item \textbf{Optional – Nachbarschaftszustand:} In Multi-Agent-Settings kann es sinnvoll sein, zusätzlich aggregierte Zustandsinformationen benachbarter Knoten einzubeziehen (z.\,B. Gesamtwarteschlange auf ausgehenden Spuren, die zu benachbarten TLS führen).
\end{itemize}

Die Zustände werden zu einem normierten Merkmalsvektor kombiniert und bilden damit die Eingabe für das neuronale Entscheidungsmodell des Agenten.

\paragraph{Aktionen}

Die Aktionsmenge \( A \) eines Agenten beschreibt die Eingriffsmöglichkeiten in den Steuerungsablauf der jeweiligen Ampelkreuzung. Dabei wird zwischen zwei gängigen Aktionsmodellen unterschieden:

\begin{enumerate}
  \item \textbf{Phasenwechsel-Modell:} Der Agent entscheidet, ob die aktuelle Phase fortgesetzt oder zur nächsten gewechselt werden soll. Es handelt sich um ein binäres Aktionsmodell:
        \[
          A = \{ \texttt{keep},\ \texttt{switch} \}
        \]
        Diese Variante wird häufig in klassischen SUMO-RL-Implementierungen verwendet (z.\,B. `sumo-rl`). Die Reihenfolge der Phasen ist dabei festgelegt (z.\,B. zyklischer Übergang).

  \item \textbf{Direktwahl-Modell:} Der Agent wählt direkt aus allen möglichen Phasen die nächste aus:
        \[
          A = \{ \texttt{phase}_0,\ \texttt{phase}_1,\ \ldots,\ \texttt{phase}_n \}
        \]
        Diese Variante erfordert eine eigene Definition der Übergangslogik in SUMO (z.\,B. über permissive TLS-Ketten), erlaubt aber größere Flexibilität und exploratives Verhalten.
\end{enumerate}

Unabhängig vom Modell gelten folgende Einschränkungen:

\begin{itemize}
  \item \textbf{Mindestgrünzeiten:} Ein Wechsel der Phase darf erst nach einer definierten Mindestgrünzeit erfolgen (z.\,B. 5 s), um realistische Signalisierung und Verkehrssicherheit zu gewährleisten.

  \item \textbf{Sicherheitsbedingte Zwischenphasen:} SUMO erzwingt automatisch Zwischenphasen wie Gelb- oder Räumzeiten. Der Agent gibt nur den Phasenwunsch an, die exakte Ablaufsteuerung erfolgt durch das TLS-Modell in SUMO.

  \item \textbf{Simultane Agentenentscheidung:} Bei mehreren Knoten wird jeder TLS-Agent unabhängig gesteuert, es sei denn, ein zentrales Multi-Agent-Training wird implementiert.
\end{itemize}

Zur Reduktion der Aktionsfrequenz wird häufig ein sogenanntes \textbf{Action Interval} festgelegt (z.\,B. alle 5 s), sodass Entscheidungen nur in bestimmten Zeitschritten getroffen werden können. Dies verhindert zu hektisches Umschalten der Ampeln.

\paragraph{Belohnungsfunktion}

Die Belohnungsfunktion ist zentrales Element des Lernprozesses und bestimmt das Optimierungsziel. Sie wurde so gestaltet, dass sie folgende Aspekte negativ gewichtet:

\begin{itemize}
  \item \textbf{Gesamte Wartezeit aller Fahrzeuge} (minimieren)
  \item \textbf{Länge der Fahrzeugschlangen} (minimieren)
  \item \textbf{Anzahl der Stopps} (minimieren)
\end{itemize}

Die konkrete Belohnung \( r_t \) zum Zeitpunkt \( t \) berechnet sich nach:

\[
  r_t = -\alpha \cdot \sum_{\text{alle Spuren}} \text{queueLength}_i(t) - \beta \cdot \sum_{\text{alle Fahrzeuge}} \text{waitingTime}_j(t)
\]

wobei \( \alpha \) und \( \beta \) Gewichtungsfaktoren darstellen, die im Rahmen der Hyperparameteroptimierung bestimmt werden. In späteren Varianten kann die Belohnung durch zusätzliche Komponenten wie Emissionen oder Energieverbrauch ergänzt werden, um umweltfreundliche Steuerungsstrategien zu fördern.

\subsection{Analyse und Herausforderungen bei der OSM-Netznutzung}


\subsubsection{Grundstruktur von Lichtsignalanlagen (TLS) in SUMO}
Bevor die Probleme beim OSM-Import analysiert werden, ist es hilfreich, den Aufbau und die Abhängigkeiten der relevanten XML-Elemente in SUMO zu verstehen, insbesondere im Zusammenhang mit der Steuerung von Lichtsignalanlagen (\textit{Traffic Light Systems, TLS}).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{images/junktion.png}
  \caption{Visualisierung einer TLS-Kreuzung (eigene Darstellung).}
  \label{fig:sumo_karlsruhe}
\end{figure}

\begin{itemize}
  \item \textbf{\texttt{<junction>}} – Definiert Knotenpunkte im Netz. Falls eine Ampel gesteuert wird, ist der Typ \texttt{type="traffic\_light"}. Die ID entspricht in der Regel der TLS-ID.

  \item \textbf{\texttt{<connection>}} – Verbindet zwei Fahrstreifen (von \texttt{from} nach \texttt{to}). Wenn diese Verbindung durch eine Ampel kontrolliert wird, enthält sie die Attribute \texttt{tl="<tls\_id>"} und \texttt{linkIndex}. Die Reihenfolge der \texttt{linkIndex}-Werte bestimmt die Position im Phasen-String.

  \item \textbf{Controlled Link} – Jede \texttt{<connection>} mit einem \texttt{tl}-Attribut zählt als „gesteuerte Verbindung“. Die Anzahl solcher Verbindungen bestimmt die Länge des Phasenstrings (\texttt{state}).

  \item \textbf{\texttt{<tlLogic>}} – Enthält die Steuerungslogik einer TLS. Jede \texttt{<tlLogic>} hat eine eindeutige ID (i.d.R. identisch zur \texttt{junction}-ID) und eine Liste von \texttt{<phase>}-Elementen.

  \item \textbf{\texttt{<phase>}} – Jede Phase ist ein String (z.B. \texttt{"Grgr"}), der den Zustand aller \texttt{linkIndex}-Verbindungen kodiert. Jeder Buchstabe (z.B. G = Grün, r = Rot) steht für den Status eines bestimmten kontrollierten Links.

  \item \textbf{\texttt{<request>}} – Optionale Anforderungen einzelner Signalgruppen, meist bei aktuierten oder adaptiven TLS. Jeder Eintrag verweist über \texttt{index=} auf einen gesteuerten Link.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
      font=\small,
      node distance=1.2cm and 3cm,
      every node/.style={align=center},
      box/.style={draw, rounded corners, minimum width=3.2cm, minimum height=1cm}
    ]

    % Hauptknoten
    \node[box] (junction) {\texttt{<junction>}\\ID = J1};
    \node[box, right=4.5cm of junction] (tlLogic) {\texttt{<tlLogic>}\\ID = J1};

    % Verbindungen unterhalb
    \node[box, below left=1.7cm and 0.4cm of junction] (conn1) {\texttt{<connection>}\\\texttt{linkIndex=0}};
    \node[box, below right=1.7cm and 0.4cm of junction] (conn2) {\texttt{<connection>}\\\texttt{linkIndex=1}};

    % Phase
    \node[box, below right=1.7cm and 0.4cm of conn1] (phase) {\texttt{<phase>}\\\texttt{state="Gr"}};

    % Kanten
    \draw[->] (junction.east) -- node[above] {\texttt{tl="J1"}} (tlLogic.west);
    \draw[->] (junction.south west) -- (conn1.north);
    \draw[->] (junction.south east) -- (conn2.north);
    \draw[->] (conn1.south) -- ([xshift=-0.8cm]phase.north);
    \draw[->] (conn2.south) -- ([xshift=+0.8cm]phase.north);

  \end{tikzpicture}
  \caption{Zusammenspiel von Kreuzung, Verbindungen und Ampellogik in SUMO}
  \label{fig:tls_structure}
\end{figure}


\subsubsection{Typische Fehlerquellen nach OSM-Import}

Die automatische Ableitung von Ampelsteuerungen aus OSM ist unvollständig und fehleranfällig. Im Zusammenspiel mit \texttt{sumo-rl} ergeben sich daraus mehrere konkrete Probleme:

\begin{itemize}
  \item \textbf{Fehlende oder unvollständige TLS-Definitionen:} In OSM sind Ampelanlagen in der Regel lediglich als Punktknoten mit dem Tag \texttt{highway=traffic\_signals} erfasst. Die genaue Schaltlogik (\texttt{tlLogic}) – inklusive Phasen und Zustände – fehlt vollständig. SUMO generiert daher beim Netzimport mit \texttt{--tls.guess-signals} heuristische Ampeldefinitionen, die jedoch oft lückenhaft oder unbrauchbar sind.

  \item \textbf{TLS mit nur einer Phase:} Viele der generierten Ampeln besitzen lediglich eine einzige definierte Phase. Dies entspricht keinem realen Verhalten und führt zu Fehlern beim Training mit \texttt{sumo-rl}, da das Framework mindestens zwei steuerbare Phasen voraussetzt. Die betroffenen Knoten müssen daher identifiziert und aus der Simulation ausgeschlossen oder manuell korrigiert werden.

  \item \textbf{Unstimmige Phasenlängen:} Jede Phase in SUMO ist ein Zeichenstring (\texttt{state}), dessen Länge der Anzahl der gesteuerten Verbindungen (sogenannte \textit{controlled links}) entsprechen muss. Bei fehlerhafter Generierung ist diese Bedingung oft verletzt – etwa wenn der \texttt{state} zu kurz oder zu lang ist. Dies führt in \texttt{sumo-rl} zu Indexfehlern oder undefiniertem Verhalten.

  \item \textbf{Fehlerhafte oder überzählige \texttt{<request>}-Einträge:} Jede TLS enthält in der Netzdatei zusätzliche Steuerinformationen über \texttt{request}-Elemente. Diese verweisen auf spezifische Signale mittels eines Index. Häufig verweisen diese Einträge jedoch auf nicht vorhandene Verbindungen, da \texttt{netconvert} Signalverknüpfungen nicht korrekt zuordnet. SUMO ignoriert solche Fehler teilweise still – \texttt{sumo-rl} hingegen bricht mit Ausnahmen ab.

  \item \textbf{Mehrdeutige oder verschachtelte Kreuzungen:} In komplexeren innerstädtischen Kreuzungen fasst SUMO mehrere OSM-Knoten zu einem „cluster“ zusammen, um den Verkehrsfluss abzubilden. Dies kann zu sehr großen TLS mit dutzenden Ein- und Ausfahrten führen, die übermäßig viele Phasen oder extrem lange Zustandsdefinitionen erzeugen. Solche TLS sind schwer zu debuggen und häufig inkompatibel mit den Erwartungen von \texttt{sumo-rl}.
\end{itemize}

\paragraph{Folgen für \texttt{sumo-rl}}

Das Framework \texttt{sumo-rl} erwartet für jede zu steuernde TLS:

\begin{itemize}
  \item mindestens zwei valide Phasen,
  \item konsistente Phasenzustände (\texttt{state}) mit korrekter Länge,
  \item vollständige Verbindungen zu kontrollierten Links,
  \item eindeutig identifizierbare TLS-IDs.
\end{itemize}

Sind diese Anforderungen nicht erfüllt, führt dies typischerweise zu einer der folgenden Fehlermeldungen:

\begin{itemize}
  \item \texttt{IndexError: string index out of range}
  \item \texttt{ValueError: Invalid phase length}
  \item \texttt{KeyError: TLS not found}
\end{itemize}

Da diese Probleme nicht durch SUMO selbst gemeldet, sondern erst zur Laufzeit in \texttt{sumo-rl} sichtbar werden, ist ein systematischer Debugging- und Reparaturprozess zwingend notwendig. Die Komplexität steigt dabei exponentiell mit der Anzahl der TLS im Netz.
\paragraph{Erkenntnis}

Der direkte Import von OSM-Daten in SUMO erzeugt ein formal nutzbares Verkehrsnetz – jedoch nicht automatisch ein für Reinforcement Learning (RL) geeignetes. Ohne zusätzliche Aufbereitung ist ein stabiler Trainingsbetrieb in \texttt{sumo-rl} nicht möglich. Im Rahmen dieser Arbeit wurde das reale OSM-Netz von Karlsruhe daher gezielt analysiert, bereinigt und überarbeitet, sodass es nun erfolgreich und stabil im RL-Kontext eingesetzt werden kann. Dazu wurden eigene Werkzeuge zur automatisierten Strukturprüfung und Reparatur entwickelt, die im folgenden Abschnitt näher beschrieben werden.

\subsubsection{Problematik nicht-motorisierter Verkehrswege im OSM-Modell}

Ein zentrales Problem beim ursprünglichen OSM-Import stellten die Strukturen nicht-motorisierter Verkehrsträger dar – insbesondere Fußwege, Überwege und Fahrradtrassen. Diese sind im OSM-Modell zwar detailliert erfasst, führen aber in SUMO häufig zu problematischen Simulationseffekten:

\begin{itemize}
  \item \textbf{Separate Fahrspuren für Radverkehr:} Zusätzliche Radstreifen erzeugen neue Kanten mit eigenen Abbiegebeziehungen, die von SUMO automatisch als TLS-relevant eingestuft werden – oft mit übermäßig vielen Signalgruppen.

  \item \textbf{Fußgängerüberwege mit Konfliktzonen:} \texttt{highway=crossing}-Elemente erzeugen automatisch Übergänge mit Konfliktzonen, die eine Ampelregelung erfordern – auch wenn sie im Originalnetz nur symbolisch vorhanden sind.

  \item \textbf{Komplexität beim Entfernen:} Die gezielte Entfernung solcher Elemente führte häufig zu inkonsistenten Junctions und Netzfragmentierung. Ein manuelles Vorgehen wäre fehleranfällig und kaum skalierbar gewesen.
\end{itemize}

Diese Herausforderungen machten eine rein automatische Nutzung des OSM-Imports zunächst unmöglich. Erst durch gezielte algorithmische Nachbearbeitung konnte das Karlsruher Netz so transformiert werden, dass es für die RL-Simulation zuverlässig nutzbar wurde.

\subsubsection{Eingesetzte \texttt{netconvert}-Optionen und deren Grenzen}

Zur automatisierten Aufbereitung kamen zahlreiche Optionen von \texttt{netconvert} zum Einsatz, um das aus OSM exportierte Netz anzupassen. Dabei zeigte sich jedoch, dass viele dieser Optionen nicht auf die hohen Anforderungen von RL-Umgebungen zugeschnitten sind:

\begin{itemize}
  \item \texttt{--tls.guess-signals}: Erzeugt Ampeln auf Basis der Netzstruktur – allerdings oft mit unrealistischen oder unbrauchbaren Phasen.

  \item \texttt{--tls.join} und \texttt{--junctions.join}: Reduzieren Komplexität, erzeugen jedoch teils unübersichtliche Cluster, die schwer manuell kontrollierbar sind.

  \item \texttt{--ramps.guess}: Für urbane Netze weitgehend irrelevant oder sogar kontraproduktiv.

  \item \texttt{--remove-edges.isolated}, \texttt{--keep-edges.by-vclass} und \texttt{--discard-simple}: Dienen der Netzvereinfachung, führen aber oft zu strukturellen Problemen oder fehlenden funktionalen Verbindungen.
\end{itemize}

Obwohl diese Optionen wichtige Vorarbeiten leisteten, war ihre Wirkung für das RL-Zielmodell begrenzt. Erst durch zusätzliche Werkzeuge und maßgeschneiderte Filterlogik konnte das Netz gezielt bereinigt und optimiert werden.

\subsubsection{Manuelle Eingriffe und strukturelle Rekonstruktionen}

Neben automatisierten Bereinigungen waren auch gezielte manuelle Anpassungen notwendig. Insbesondere wurden mithilfe von \texttt{netedit} einzelne Kreuzungen vollständig neu aufgebaut, um \textbf{Deadlocks zu vermeiden}, die zwar in der realen Verkehrsführung nicht auftreten, jedoch in SUMO durch implizite Abbiegelogiken und Vorrangregeln entstehen können.

Diese Rekonstruktionen erfolgten unter Beibehaltung der realweltlichen Topologie, jedoch mit einer technisch sauberen Definition aller Fahrbeziehungen und Signalisierungen. Damit konnte sichergestellt werden, dass auch komplexere Kreuzungen reproduzierbar, konfliktfrei und steuerbar bleiben.

\subsubsection{Ergebnis: ein realistisches, RL-kompatibles Netz}

Im Gegensatz zu einer synthetischen Umgebung basiert das nun eingesetzte Trainingsnetz auf realen topologischen Daten, wurde jedoch gezielt für den Einsatz mit \texttt{sumo-rl} überarbeitet. Es erfüllt folgende Eigenschaften:

\begin{itemize}
  \item \textbf{Hohe Realitätsnähe bei kontrollierter Komplexität:} Das Netz bildet reale Strukturen ab, wurde jedoch so bereinigt, dass es RL-kompatibel bleibt.

  \item \textbf{Stabile TLS-Struktur:} Alle Kreuzungen mit Lichtsignalanlagen enthalten reproduzierbare und sinnvoll steuerbare Phasen.

  \item \textbf{Fehlerminimierung und Modularität:} Durch gezielte Reduktion und Nachbearbeitung sind Trainingsläufe wiederholbar und ohne strukturelle Störungen durchführbar.

  \item \textbf{Deadlock-Vermeidung durch gezielte Rekonstruktion:} Kritische Junctions wurden manuell so modelliert, dass sie SUMO-spezifische Blockadesituationen vermeiden, ohne die Realität zu verzerren.
\end{itemize}

Der Einsatz dieses verbesserten Karlsruher Netzes stellt einen zentralen methodischen Beitrag dieser Arbeit dar, da er demonstriert, wie reale OSM-Daten erfolgreich für das Reinforcement Learning nutzbar gemacht werden können – trotz ihrer ursprünglichen Limitierungen.


\subsection{Netzprüfung, Reparatur und Toolchain}
Aufgrund der oben beschriebenen strukturellen Schwächen im importierten OSM-Netz war eine manuelle Nachbearbeitung ineffizient und fehleranfällig. Daher wurden eigene Werkzeuge entwickelt, um eine systematische und automatisierte Reparatur zu ermöglichen.


\subsubsection{Werkzeuge zur Netzprüfung und Reparatur}

Um die Kompatibilität des aus OpenStreetMap abgeleiteten Verkehrsnetzes mit \texttt{sumo-rl} sicherzustellen, wurde eine Reihe eigenentwickelter Python-Skripte implementiert. Diese Werkzeuge automatisieren die Analyse, Validierung und Korrektur der Netzstruktur mit Fokus auf Lichtsignalanlagen (TLS). Der modulare Aufbau erlaubt es, problematische Netzbestandteile zu identifizieren und gezielt zu bereinigen.

\paragraph{Prüfung der Signalverknüpfungen und Zustandslängen}

Zwei zentrale Tools wurden entwickelt, um die Konsistenz zwischen kontrollierten Verbindungen (\textit{controlled links}) und Phasenzuständen (\texttt{state}) der TLS zu überprüfen:

\begin{itemize}
  \item \textbf{\texttt{check\_tls\_consistency.py}} prüft, ob die Länge jedes \texttt{state}-Strings in den \texttt{<phase>}-Elementen exakt der Anzahl der gesteuerten Signalindizes entspricht. Abweichungen werden detailliert gelistet, inklusive betroffener Phase und TLS-ID.

        \begin{algorithm}[H]
          \caption{CheckTLSLengths – Prüfung inkonsistenter Phasenlängen}
          \begin{algorithmic}[1]
            \Function{CheckTLSLengths}{net.xml}
            \State Lade XML-Baum und extrahiere \texttt{<connection>}-Elemente
            \State Erstelle Dictionary \texttt{tls\_controlled\_links} mit Anzahl gesteuerter Links pro TLS
            \ForAll{\texttt{tlLogic}-Elemente im Netz}
            \State \texttt{expectedLen} $\gets$ Anzahl \texttt{controlledLinks} aus Dictionary
            \If{\texttt{expectedLen} = 0}
            \State Gib Warnung: TLS hat keine gesteuerten Verbindungen
            \State \textbf{continue}
            \EndIf
            \ForAll{Phasen $i$ in \texttt{tlLogic}}
            \State \texttt{actualLen} $\gets$ Länge des \texttt{state}-Strings
            \If{\texttt{actualLen} $\neq$ \texttt{expectedLen}}
            \State Gib Warnung mit TLS-ID, Phase und \texttt{state}-Inhalt aus
            \EndIf
            \EndFor
            \EndFor
            \If{keine Abweichungen gefunden}
            \State Gib Erfolgsmeldung aus
            \EndIf
            \EndFunction
          \end{algorithmic}
        \end{algorithm}

  \item \textbf{\texttt{check\_tls\_requests.py}} validiert, ob alle \texttt{<request>}-Indizes innerhalb zulässiger Grenzen liegen. Falsch verknüpfte Einträge – z.\,B. \texttt{index > max(signalIndex)} – werden gemeldet.

        \begin{algorithm}[H]
          \caption{CheckTLSRequests – Prüfung ungültiger \texttt{request}-Indizes}
          \begin{algorithmic}[1]
            \Function{CheckTLSRequests}{net.xml}
            \State Lade XML-Datei und parse Wurzelknoten
            \State Erzeuge Dictionary \texttt{tls\_signal\_indices} mit Signalindizes je TLS aus \texttt{<connection>}-Elementen
            \ForAll{\texttt{junction}-Elemente im Netz}
            \State \texttt{tls\_id} $\gets$ ID der Junction
            \If{\texttt{tls\_id} in \texttt{tls\_signal\_indices}}
            \State \texttt{expected\_max} $\gets$ Länge der Signalindizes für dieses TLS
            \ForAll{\texttt{request}-Elemente in Junction}
            \State \texttt{index} $\gets$ Wert des \texttt{index}-Attributs
            \If{\texttt{index} $\geq$ \texttt{expected\_max}}
            \State Gib Warnung mit \texttt{tls\_id} und \texttt{index} aus
            \EndIf
            \EndFor
            \EndIf
            \EndFor
            \If{keine Warnungen ausgegeben}
            \State Gib Erfolgsmeldung aus
            \EndIf
            \EndFunction
          \end{algorithmic}
        \end{algorithm}
\end{itemize}

\paragraph{Automatische Reparaturwerkzeuge}

Die folgenden Programme wurden zur strukturellen Korrektur entwickelt:

\begin{itemize}
  \item \textbf{\texttt{fix\_requests.py}} entfernt überzählige \texttt{<request>}-Einträge und kürzt \texttt{state}-Strings in Phasen auf die zulässige Länge. Die Bereinigung erfolgt anhand der tatsächlichen Anzahl gesteuerter Signalverbindungen (\texttt{linkIndex}).

        \begin{algorithm}[H]
          \caption{FixRequests – Bereinigung ungültiger \texttt{<request>}-Einträge und Anpassung der Phasen}
          \begin{algorithmic}[1]
            \Function{FixRequests}{net.xml}
            \State Lade XML-Baum mit Netzstruktur
            \State Initialisiere Dictionary \texttt{tls\_max\_index} für maximale Signalindices
            \ForAll{\texttt{connection}-Elemente}
            \If{TLS-ID und \texttt{linkIndex} vorhanden}
            \State Aktualisiere \texttt{tls\_max\_index[tl]} mit höchstem Index
            \EndIf
            \EndFor

            \ForAll{\texttt{junction}-Elemente}
            \State Hole TLS-ID
            \If{TLS nicht in \texttt{tls\_max\_index}}
            \State \textbf{continue}
            \EndIf
            \State Bestimme erlaubten Maximalindex (\texttt{max\_idx})
            \ForAll{\texttt{request}-Einträge}
            \If{Index $>$ \texttt{max\_idx}}
            \State Entferne ungültigen \texttt{request}
            \EndIf
            \EndFor

            \ForAll{\texttt{tlLogic}-Elemente mit passender TLS-ID}
            \ForAll{Phasen}
            \If{\texttt{state}-String ist zu lang}
            \State Kürze \texttt{state} auf \texttt{max\_idx + 1}
            \EndIf
            \EndFor
            \EndFor
            \EndFor

            \State Speichere modifizierte XML-Datei
            \State Gib Statistiken zu entfernten Requests und angepassten Phasen aus
            \EndFunction
          \end{algorithmic}
        \end{algorithm}

  \item \textbf{\texttt{repair-net.py}} nutzt ein manuell gepflegtes Dictionary mit TLS-IDs und deren erwarteter Phasenlänge (Anzahl kontrollierter Verbindungen). Alle Phasen, deren Länge abweicht, werden automatisch gekürzt oder aufgefüllt.

        \begin{algorithm}[H]
          \caption{RepairTLSStates – Korrektur der Phasenlängen anhand manuell gepflegter Referenz}
          \begin{algorithmic}[1]
            \Function{RepairTLSStates}{net.xml, referenz\_dictionary}
            \State Lade Netzstruktur aus \texttt{net.xml}
            \ForAll{\texttt{tlLogic}-Elemente im Netz}
            \State \texttt{tls\_id} $\gets$ ID des Ampelknotens
            \If{\texttt{tls\_id} nicht in referenz\_dictionary}
            \State \textbf{continue}
            \EndIf
            \State \texttt{correctLen} $\gets$ erwartete Zustandslänge aus Referenz
            \ForAll{Phasen des Knotens}
            \State \texttt{state} $\gets$ Zeichenkette der Phase
            \If{Länge(\texttt{state}) $\neq$ \texttt{correctLen}}
            \State Kürze oder ergänze \texttt{state} auf \texttt{correctLen}
            \State Markiere Netz als geändert
            \EndIf
            \EndFor
            \EndFor
            \If{Netz wurde geändert}
            \State Speichere bereinigte Netzdatei als \texttt{karlsruhe\_fixed.net.xml}
            \Else
            \State Gib Hinweis: Alle Phasen bereits korrekt
            \EndIf
            \EndFunction
          \end{algorithmic}
        \end{algorithm}

  \item \textbf{\texttt{statecheck.py}} gibt eine Liste aller TLS-Phasen mit ungewöhnlichen Längen aus. Dieses Tool wurde verwendet, um bei vereinheitlichten Netzen auf eine Ziel-Zustandslänge zu prüfen.

        \begin{algorithm}[H]
          \caption{StateCheck – Prüfung auf einheitliche Phasenlängen}
          \begin{algorithmic}[1]
            \Function{StateCheck}{net.xml}
            \State Lade XML-Baum aus der Netzdatei
            \ForAll{\texttt{tlLogic}-Elemente im Netz}
            \State \texttt{tl\_id} $\gets$ ID des aktuellen TLS
            \ForAll{Phasen $i$ in \texttt{tlLogic}}
            \State \texttt{state} $\gets$ Zustand der Phase
            \If{\texttt{len(state)} $\neq$ 57}
            \State Gib Warnung mit \texttt{tl\_id}, Phasenindex und tatsächlicher Länge aus
            \EndIf
            \EndFor
            \EndFor
            \EndFunction
          \end{algorithmic}
        \end{algorithm}

\end{itemize}

\newpage
\paragraph{Gültigkeitsprüfung für SUMO-RL}

Zur Vorbereitung des Trainings wurden weitere Programme zur Identifikation funktionaler TLS entwickelt:

\begin{itemize}
  \item \textbf{\texttt{find\_valid\_tls.py}} iteriert über alle TLS im Netz und testet jede einzeln in einem minimalen \texttt{sumo-rl}-Lauf. TLS, bei denen die Umgebung erfolgreich initialisiert werden kann, gelten als kompatibel.

        \begin{algorithm}[H]
          \caption{FindValidTLS – Gültigkeitsprüfung aller TLS im Netz}
          \begin{algorithmic}[1]
            \Function{TestTLS}{\texttt{tls\_id}}
            \State Initialisiere \texttt{SumoEnvironment}
            \State Setze \texttt{ts\_ids} auf \texttt{[tls\_id]}
            \State Versuche: \texttt{env.reset()}
            \If{kein Fehler}
            \State \texttt{env.close()}
            \State \Return \texttt{True}
            \Else
            \State Gib Fehlermeldung aus
            \State \Return \texttt{False}
            \EndIf
            \EndFunction
            \vspace{0.5em}
            \State Initialisiere leere Liste \texttt{all\_tls}
            \State Versuche: Umgebung mit \texttt{SumoEnvironment} zu starten
            \If{erfolgreich}
            \State Lese alle \texttt{ts\_ids}
            \State Schließe Umgebung
            \Else
            \State Gib Fehler aus
            \EndIf
            \vspace{0.5em}
            \State Initialisiere leere Liste \texttt{valid\_tls}
            \ForAll{\texttt{tls\_id} in \texttt{all\_tls}}
            \If{ \Call{TestTLS}{\texttt{tls\_id}} }
            \State Füge \texttt{tls\_id} zu \texttt{valid\_tls} hinzu
            \EndIf
            \EndFor
            \State Gib alle gültigen TLS aus
          \end{algorithmic}
        \end{algorithm}
\end{itemize}

\subsubsection{Auswahl eines bereinigten Netzes}

Nach mehrfacher Iteration und Debugging wurde ein final bereinigtes Netz erzeugt: \texttt{karlsruhe.net.xml}. Dieses enthält ausschließlich überprüfte TLS mit konsistenten Phasenlängen und steuerbaren Verbindungen. Es bildet die Grundlage für alle nachfolgenden Reinforcement-Learning-Experimente.

\subsubsection{Vorteil des automatisierten Workflows}

Die entwickelte Toolchain ermöglicht:

\begin{itemize}
  \item eine strukturierte Diagnose typischer OSM-bedingter Netzprobleme,
  \item reproduzierbare Netzreparaturen ohne reines manuelles Editieren in \texttt{netedit},
  \item gezielte Selektion steuerbarer TLS für das Experiment.
\end{itemize}

Der Einsatz dieser Werkzeuge war unerlässlich, um ein funktionales, kompatibles und robusteres Simulationsnetz auf Basis realer OSM-Daten zu etablieren.

\subsection{Einbindung des SUMO-Netzes in die RL-Umgebung}
\label{sec:sumo-rl-architektur}

Nach Abschluss der Netzbereinigung, der strukturellen Validierung und der Identifikation steuerbarer Lichtsignalanlagen (TLS) wurde das finale Verkehrsnetz in eine auf \texttt{sumo-rl} basierende Reinforcement-Learning-Umgebung integriert. Ziel war die Realisierung einer robusten, modularen Multiagentenumgebung, die eine lernbasierte Optimierung der Verkehrssteuerung unter realitätsnahen Bedingungen erlaubt.

\subsubsection{Gesamtsystem und Architektur}

Die Architektur der Lernumgebung ist als verteiltes Multiagentensystem ausgelegt, bei dem jede signalgesteuerte Kreuzung durch einen eigenständigen Agenten repräsentiert wird. Die Interaktion erfolgt über das TraCI-Protokoll von SUMO, das eine Echtzeitkommunikation zwischen Simulator und RL-Agenten ermöglicht. Die zentrale Steuerung und das Training der Agenten basiert auf der RL-Bibliothek \texttt{Stable-Baselines3}, konkret dem Algorithmus \texttt{Proximal Policy Optimization (PPO)}.


\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.2cm]

    \node[box] (sim) {Verkehrssimulation\\\textbf{SUMO + Traci}};
    \node[box, below=of sim] (mae) {Multi-Agent Environment (MAE)\\\texttt{sumo-rl.parallel\_env} + \texttt{custom\_reward}};
    \node[box, below=of mae] (wrap) {Supersuit Wrappers\\\texttt{- pad\_obs / pad\_actions}\\\texttt{- pettingzoo\_to\_vec\_env}};
    \node[box, below=of wrap] (vec) {VecNormalize + VecMonitor\\(Stable-Baselines3)};
    \node[box, below=of vec] (ppo) {PPO Agent (Stable-Baselines3)\\\texttt{- MLPPolicy}\\\texttt{- Schedules: LR, Clip, Ent.}};
    \node[box, below=of ppo] (cb) {Callbacks\\\texttt{- TimeBasedCheckpoint}\\\texttt{- BestModelSaver (mean\_reward)}\\\texttt{- LearningRateLogger}};
    \node[box, below=of cb] (log) {Modell- \& Log-Speicherung\\\texttt{(pro Seed in runs/)}};

    % Arrows
    \draw[arrow] (sim) -- (mae);
    \draw[arrow] (mae) -- (wrap);
    \draw[arrow] (wrap) -- (vec);
    \draw[arrow] (vec) -- (ppo);
    \draw[arrow] (ppo) -- (cb);
    \draw[arrow] (cb) -- (log);

  \end{tikzpicture}
  \caption{Architektur der RL-Trainingspipeline mit SUMO, MAE und Stable-Baselines3}
  \label{fig:rl_architektur}
\end{figure}

\subsubsection{Konfiguration der Umgebung}

Die Reinforcement-Learning-Umgebung wurde auf Basis der Klasse \texttt{SumoEnvironment} bzw. \texttt{parallel\_env} aus \texttt{sumo-rl} konfiguriert. Wichtige Parameter umfassen:

\begin{itemize}
  \item \texttt{net\_file}, \texttt{route\_file}: Pfade zum bereinigten Verkehrsnetz und zugehöriger Routendatei.
  \item \texttt{use\_gui}: Aktiviert die grafische Visualisierung von SUMO (zur Laufzeit abschaltbar für Trainingsgeschwindigkeit).
  \item \texttt{num\_seconds}: Dauer einer Simulationsepisode in Sekunden.
  \item \texttt{reward\_fn}: Referenz auf die benutzerdefinierte Belohnungsfunktion.
  \item \texttt{min\_green}: Minimale Grünphasenlänge in Sekunden zur Sicherstellung realistischer Signalzyklen.
  \item \texttt{max\_depart\_delay}: Maximale Verzögerung bei der Einfahrt eines Fahrzeugs (zur Kontrolle der Spawn-Zeit).
  \item \texttt{sumo\_seed}: Zufalls-Seed zur Reproduzierbarkeit von Verkehrsflüssen und Routenentscheidungen.
  \item \texttt{add\_system\_info}: Wenn aktiviert, werden systemweite Kennzahlen (z.\,B. durchschnittliche Wartezeit) in die Beobachtung eingebettet.
  \item \texttt{add\_per\_agent\_info}: Ergänzt die lokale Beobachtung jedes Agenten um zusätzliche Kontextdaten (z.\,B. Verkehrsdichte im Knoten).
  \item \texttt{single\_agent = False}: Aktiviert den Multiagentenmodus, bei dem jede steuerbare Ampel einen separaten Agenten darstellt.
\end{itemize}

Die Umgebung ist vollständig kompatibel mit \texttt{Gymnasium}, \texttt{PettingZoo} sowie den Wrapper-Bibliotheken \texttt{SuperSuit} und \texttt{VecEnv}, wodurch ein standardisiertes Interfacing mit RL-Algorithmen ermöglicht wird.

\subsubsection{Beobachtungen und Aktionsraum}

Jeder Agent erhält eine lokale Beobachtung, die sich aus folgenden Informationen zusammensetzt:

\begin{itemize}
  \item aktuelle Ampelphase (diskreter Index oder One-Hot-Encoding),
  \item Dauer der aktuellen Phase (zur Einhaltung von Mindestzeiten),
  \item für jede anliegende Spur: Anzahl wartender Fahrzeuge, durchschnittliche Geschwindigkeit, Dichte.
\end{itemize}

Der Aktionsraum ist diskret und erlaubt die Auswahl der nächsten Phase. Der Phasenwechsel wird durch SUMO automatisch mit einer Zwischenphase (Gelbphase) ergänzt. Die Entscheidung erfolgt synchron für alle Agenten alle \texttt{delta\_time} Sekunden.

\subsubsection{Belohnungsfunktionen}

\texttt{sumo-rl} unterstützt verschiedene standardisierte Reward-Funktionen:

\begin{itemize}
  \item \texttt{"diff-waiting-time"}: Reduktion der Differenz kumulierter Wartezeiten,
  \item \texttt{\char`\"average-speed"}: Maximierung der mittleren Geschwindigkeit im Netz,
  \item \texttt{"queue"}: Minimierung der Gesamtlänge aller Warteschlangen.
\end{itemize}

Im Rahmen dieser Arbeit wurde zusätzlich eine eigene Reward-Funktion definiert, welche folgende Größen kombiniert:

\begin{itemize}
  \item aktuelle Warteschlangenlänge (negativ),
  \item akkumulierte Wartezeiten (negativ),
  \item Anzahl an Teleportationen und Kollisionen (stark negativ),
  \item Anzahl neu eingetroffener Fahrzeuge (positiv),
  \item Veränderung der Stauhöhe zur Vorperiode (positiv).
\end{itemize}

Die Belohnung wird nach jedem Simulationsschritt einzeln für jeden TLS-Agenten berechnet. Extreme Ereignisse (z.\,B. viele Teleports) führen zu stark negativen Strafwerten, um stabile Lernverläufe zu fördern.

\subsubsection{Trainingsalgorithmus und Hyperparameter}

Das Training der Agenten erfolgte mittels \texttt{PPO}, wobei folgende Hyperparameter eingesetzt wurden:

\begin{itemize}
  \item \textbf{Policy-Architektur:} Zwei Hidden-Layer mit jeweils 128 Neuronen,
  \item \textbf{Batchgröße:} 2048,
  \item \textbf{Lernrate:} linear abnehmend von $3\cdot10^{-4}$,
  \item \textbf{Clip-Range:} dynamisch, linear von 0.2 auf 0.1,
  \item \textbf{Entropiekoeffizient:} $0.005$ zur Förderung explorativen Verhaltens,
  \item \textbf{Discount-Faktor:} $\gamma = 0.99$,
  \item \textbf{GAE-Lambda:} $0.95$ für stabilisierte Vorteilsschätzung.
\end{itemize}

Die Umgebung wurde über \texttt{VecNormalize} normalisiert und mit \texttt{VecMonitor} überwacht. Zusätzlich kamen Wrapper zur Aktion- und Beobachtungsstandardisierung (\texttt{pad\_observations\_v0}, \texttt{pad\_action\_space\_v0}) zum Einsatz, um variable TLS-Strukturen zu harmonisieren.

\subsubsection{Checkpoints, Monitoring und Logging}

Zur Sicherstellung eines robusten Trainingsprozesses wurde eine Reihe von Callback-Mechanismen implementiert:

\begin{itemize}
  \item \textbf{Checkpointing:} Zeitbasierte Sicherung des Modells alle 60 Minuten,
  \item \textbf{Bestmodell-Erkennung:} Automatische Speicherung des jeweils besten Modells (höchste mittlere Reward),
  \item \textbf{Adaptive Schedules:} Dynamische Anpassung von Lernrate und Clip-Range an den Trainingsfortschritt,
  \item \textbf{Logging via TensorBoard:} Visualisierung von Reward-Kurven, Lernraten, Clip-Werten und Modellmetriken.
\end{itemize}

Alle Modellartefakte (\texttt{.zip}, \texttt{vecnormalize.pkl}) sowie die TensorBoard-Logs wurden pro Seed-Version strukturiert gespeichert. Dadurch konnten sowohl Reproduzierbarkeit als auch vergleichende Auswertungen zwischen Trainingsläufen gewährleistet werden.

\subsubsection{Zusammenfassung}

Die konfigurierte RL-Umgebung erlaubt eine modulare und flexible Steuerung realer Verkehrsnetze auf Basis von SUMO. Durch die Kombination aus systematischer TLS-Auswahl, stabiler Reward-Funktion, adaptiven Trainingsparametern und umfassendem Monitoring wurde eine solide Grundlage für die experimentelle Evaluation lernbasierter Verkehrssteuerung geschaffen.
