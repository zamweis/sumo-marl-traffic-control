\documentclass[a4paper, ngerman, 10pt]{article}

% code
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{minted}

% Eingabecodierung und Sprachunterstützung
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{float}

% Typografie und Layout
\usepackage{lmodern}
\usepackage{microtype}

% Links und URLs
\usepackage{hyperref}

% Bilder und Grafiken
\usepackage{graphicx}

% Aufzählungen
\usepackage{enumitem}

\usepackage[a4paper, top=4cm, bottom=4cm, left=4cm, right=4cm]{geometry}

% Mathematische Ausdrücke
\usepackage{amsmath}

% TikZ für grafische Elemente
\usepackage{tikz}
\usetikzlibrary{positioning}

% Image folder
\graphicspath{{images/}}

% Hyperlink setup
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,      
  urlcolor=cyan,
}

\title{Optimierung einer Verkehrssimulation mit KI-basierten Agenten in SUMO}
\author{Sam Weiler}
\date{\small \today}
\begin{document}

\begin{titlepage}
    \centering
    \includegraphics[width=5cm]{HKA_IWI_Wortmarke_RGB.jpg}
    \hspace{2cm}
    \includegraphics[width=3cm]{HKA_IWI_Bildmarke_RGB.jpg}
    \vspace{2cm}

    \Large
    \textbf{Optimierung einer Verkehrssimulation mit KI-basierten Agenten in SUMO}
    
    \vspace{2cm}

    Studiengang Informatik\\
    
    Sam Weiler\\
    Matr. Nr. 73640\\
\end{titlepage}

\tableofcontents
\newpage

\section{Einleitung}

\subsection{Motivation und Problemstellung}

Städte stehen zunehmend vor der Herausforderung, mit den wachsenden Anforderungen des urbanen Verkehrs zurechtzukommen. Die Zahl der Fahrzeuge im Individualverkehr steigt kontinuierlich, was zu einer Verdichtung des Verkehrsaufkommens, insbesondere in städtischen Knotenpunkten, führt. Die daraus resultierenden Konsequenzen sind vielfältig: Verkehrsüberlastungen führen zu erhöhten Reisezeiten, steigenden Emissionen und einer verminderten Lebensqualität für die Bevölkerung. Darüber hinaus verursacht ineffizienter Verkehr einen erheblichen wirtschaftlichen Schaden durch Zeitverluste und Ressourcenverschwendung.

Ein zentraler Hebel zur Verbesserung dieser Situation liegt in der intelligenten Steuerung des Verkehrsflusses – insbesondere an Kreuzungen, an denen mehrere Verkehrsströme aufeinandertreffen. Die Lichtsignalanlagen, die dort zum Einsatz kommen, arbeiten vielerorts noch nach starren, zeitbasierten Schaltplänen, die selten in Echtzeit auf veränderte Verkehrssituationen reagieren. Auch adaptive Verfahren, wie verkehrsabhängige Steuerungen mittels Induktionsschleifen oder Kameras, sind in ihrer Reaktionsfähigkeit beschränkt und oft teuer in der Wartung. Damit bleibt ein enormes Potenzial zur Effizienzsteigerung ungenutzt.

Vor diesem Hintergrund bietet die Kombination moderner Simulationstechniken mit Methoden der künstlichen Intelligenz – insbesondere dem \textit{Reinforcement Learning} – eine vielversprechende Alternative. Reinforcement Learning (RL) ist ein lernbasiertes Verfahren, bei dem ein Agent durch Interaktion mit einer Umgebung eine optimale Strategie zur Maximierung eines definierten Belohnungskriteriums erlernt. Die Anwendung dieses Konzepts auf Ampelsteuerungen erlaubt es, reaktive, datengestützte Systeme zu entwickeln, die dynamisch auf die aktuelle Verkehrssituation reagieren und dabei auf langfristige Effizienz optimiert sind.

Zur Erprobung solcher Verfahren eignet sich die Verkehrssimulationsumgebung \textit{SUMO} (Simulation of Urban MObility)\cite{sumo-doc}, eine quelloffene, modular aufgebaute Plattform, die es ermöglicht, Verkehrsflüsse realitätsnah zu modellieren und zu analysieren. In Kombination mit dem Framework \texttt{sumo-rl}\cite{sumo-rl}, das eine Brücke zwischen SUMO und gängigen Machine-Learning-Frameworks wie TensorFlow oder PyTorch schlägt, lassen sich Reinforcement-Learning-Agenten direkt in die Simulationsumgebung einbetten. Diese können dann die Steuerung einzelner Ampelanlagen übernehmen und ihre Strategien durch wiederholte Simulation iterativ verbessern.

\subsection{Zielsetzung der Arbeit}

Ziel dieser Bachelorarbeit ist es, eine auf Reinforcement Learning basierende Steuerung von Ampelanlagen innerhalb eines realitätsnahen, simulierten städtischen Verkehrsnetzes zu entwickeln, umzusetzen und zu evaluieren. Als Modellregion dient ein ausgewählter, stark befahrener Bereich der Stadt Karlsruhe, dessen Straßennetz mithilfe von OpenStreetMap-Daten und Verkehrsdaten von Institutionen wie LUBW, MobiData BW und der Bundesanstalt für Straßenwesen realitätsnah abgebildet wird.

Die Arbeit verfolgt einen anwendungsorientierten Ansatz: Es wird ein vollständiges System aufgebaut, in dem einzelne Ampelkreuzungen durch RL-Agenten gesteuert werden. Diese erhalten als Eingabe Informationen zur aktuellen Verkehrslage, etwa Fahrzeuganzahl, Wartezeiten oder Stauentwicklungen, und geben als Ausgabe Ampelschaltbefehle zurück. Ziel ist es, durch Training in der Simulation eine Steuerungsstrategie zu entwickeln, die relevante Zielgrößen wie die durchschnittliche Wartezeit, den Verkehrsfluss oder die Anzahl von Fahrzeugstopps optimiert.

Ein positiver Untersuchungsverlauf könnte zeigen, dass bestehende Straßennetze effizienter genutzt werden können – ohne kostspielige Neubauten oder Erweiterungen. Die verbesserte Auslastung bestehender Infrastruktur spart Kosten, reduziert Flächenversiegelung und mindert Umweltbelastung durch Verkehrsvermeidung. Außerdem wäre ein solches adaptive System klimafreundlicher als starre Ampelsteuerungen.

Darüber hinaus soll die Arbeit systematisch untersuchen, wie sich unterschiedliche Modellierungsentscheidungen (z.B. Wahl der Belohnungsfunktion, Anzahl der gesteuerten Agenten, Parametrisierung der Umgebung) auf das Verhalten und die Leistungsfähigkeit der lernenden Agenten auswirken. Die gewonnenen Erkenntnisse sollen kritisch reflektiert und mit konventionellen, nicht-adaptiven Steuerungsstrategien verglichen werden.
\subsection{Begrenzung des Projektumfangs}

Trotz des Anspruchs auf Realitätsnähe handelt es sich bei der vorliegenden Arbeit um ein simulationsbasiertes Projekt mit bewusst gewähltem Fokus. Die Umsetzung erfolgt ausschließlich in der Simulationsumgebung SUMO und basiert auf öffentlich zugänglichen Geodaten (OpenStreetMap) sowie begrenzt verfügbaren Verkehrsdaten von staatlichen und kommunalen Institutionen. Eine vollständige Abbildung aller Aspekte des realen Straßenverkehrs ist damit weder angestrebt noch möglich.\cite{sumo-doc}

Insbesondere ergeben sich folgende Einschränkungen:

\begin{itemize}
    \item \textbf{Eingeschränkte Datenverfügbarkeit:} Nicht alle für eine realitätsnahe Verkehrsmodellierung relevanten Daten liegen in ausreichender Qualität oder Auflösung vor. Exakte Ampelschaltzeiten, Fußgängerfrequenzen oder dynamische Verkehrsdaten zu Stoßzeiten sind teilweise nicht öffentlich zugänglich oder nur unvollständig. Dazu kommt, dass Kommunen teilweise bewusst den Verkehr lenken – etwa durch Zufahrtsbeschränkungen oder Verkehrsberuhigungszonen –, was oft nicht öffentlich kommuniziert wird.
    
    \item \textbf{Vereinfachte Modellierung der Umgebung:} In der Simulation wird angenommen, dass alle Verkehrsteilnehmer (Fahrzeuge, Fußgänger, Radfahrer) durch die Agenten präzise erfasst werden können – eine Annahme, die in der Realität durch technische und datenschutzrechtliche Hürden nicht haltbar ist. Moderne Systeme arbeiten hier mit Datenschutz‑mechanismen, aber eine flächendeckende, genaue Erfassung ist unerlässlich, aber derzeit technisch und rechtlich nicht umsetzbar.
    
    \item \textbf{Städtebauliche Verkehrslenkung:} In der Realität regeln Städte Verkehrsflüsse z.B. durch Low‑Traffic‑Neighbourhoods, Zufahrtsbeschränkungen oder geregelte Zuflusssteuerung, um bestimmte Stadtbereiche zu entlasten. Solche Maßnahmen sind jedoch in der Simulationsumgebung nicht dynamisch abbildbar, da nur externe Ampelagenten kontrollieren und keine zonale Steuerungslogik abgebildet wird.
    
    \item \textbf{Begrenzter räumlicher und zeitlicher Umfang:} Simuliert wird lediglich ein ausgewählter Ausschnitt des Karlsruher Straßennetzes und nur für definierte Zeitabschnitte. Eine vollständige Tag‑Nacht‑Modellierung oder eine Darstellung saisonaler sowie städtischer Ereigniszeiten liegt außerhalb des Umfangs.
    
    \item \textbf{Trainings- und Evaluierungsgrenzen:} Reinforcement‑Learning‑Agenten benötigen viele Trainingszyklen. Die in dieser Arbeit verwendete Hardware limitiert Trainingsdauer und Modellkomplexität.
\end{itemize}

Diese bewusste Eingrenzung ermöglicht es, sich auf die technische Umsetzbarkeit und das methodische Vorgehen zu konzentrieren. Dennoch sind die gewonnenen Erkenntnisse relevant – sie liefern zentrale Einsichten in die Wirksamkeit von KI‑basierten Verkehrssteuerungssystemen und können als Grundlage für weiterführende Forschung dienen.

\subsection{Wissenschaftliche und gesellschaftliche Relevanz}

Die Kombination von KI und Verkehrssteuerung ist nicht nur ein hochaktuelles Forschungsthema, sondern besitzt auch ein erhebliches Potenzial für den realweltlichen Einsatz. Durch die Integration lernfähiger Steuerungssysteme in bestehende Verkehrsmanagementlösungen könnten Städte künftig dynamischer, effizienter und umweltfreundlicher agieren. Die hier behandelte Arbeit leistet einen Beitrag zur Untersuchung der technischen Machbarkeit sowie der Leistungsfähigkeit solcher Systeme unter realitätsnahen Bedingungen.

Gleichzeitig dient die Arbeit als Beispiel für den Einsatz moderner Methoden der Informatik in einem interdisziplinären Anwendungsfeld. Sie schlägt die Brücke zwischen Verkehrsingenieurwesen, Datenanalyse und maschinellem Lernen und eröffnet damit Perspektiven für eine zukunftsweisende Gestaltung urbaner Infrastrukturen.

\subsection{Aufbau der Arbeit}

Die Arbeit ist in sieben Kapitel unterteilt:

\begin{itemize}
    \item Kapitel 2 stellt die theoretischen Grundlagen der Arbeit dar. Es werden die Funktionsweise von SUMO, die Prinzipien des Reinforcement Learning sowie die zugrundeliegenden technischen Komponenten erläutert. Auch verwandte Arbeiten werden kritisch betrachtet.
    \item Kapitel 3 widmet sich den Datenquellen und der Modellierungsgrundlage. Es werden sowohl die verwendeten Geodaten als auch Verkehrszählungen, Ampelschaltpläne und Annahmen beschrieben.
    \item Kapitel 4 beschreibt die methodische Vorgehensweise bei der Erstellung des Simulationsmodells, der Formulierung des Lernproblems, der Wahl der Trainingsstrategie und der technischen Umsetzung.
    \item Kapitel 5 präsentiert die Ergebnisse der Simulationen und stellt sie in Bezug zur gewählten Zielsetzung. Es erfolgt eine quantitative und qualitative Auswertung der Agentenleistung.
    \item Kapitel 6 diskutiert zentrale Herausforderungen und Limitationen der Arbeit, sowohl methodisch als auch datenbezogen.
    \item Kapitel 7 fasst die wesentlichen Erkenntnisse zusammen und gibt einen Ausblick auf weiterführende Forschungsansätze und Anwendungsoptionen.
\end{itemize}

\section{Hintergrund und Stand der Technik}

\subsection{Urbane Verkehrssysteme und Verkehrssteuerung}

Die urbane Verkehrssteuerung umfasst alle Maßnahmen zur Regelung, Lenkung und Optimierung von Verkehrsflüssen innerhalb städtischer Räume. Ziel ist es, den Verkehrsfluss effizient zu gestalten, Staus zu vermeiden, die Sicherheit aller Verkehrsteilnehmer zu erhöhen sowie Emissionen und Lärm zu reduzieren. Klassische Steuerungsmechanismen basieren häufig auf festen Zeitplänen oder einfachen verkehrsabhängigen Regeln, z.\,B. durch Induktionsschleifen oder Detektoren gesteuerte Ampelphasen.

Mit dem Aufkommen neuer Technologien und wachsender Mobilitätsdaten entstehen zunehmend datenbasierte und dynamische Steuerungsansätze. Dazu gehören adaptive Lichtsignalsteuerungen, vernetzte Fahrzeuge (V2X-Kommunikation) und erste Pilotprojekte mit KI-gesteuerten Verkehrsmanagementsystemen. Dennoch sind viele Systeme in der Praxis noch unflexibel oder schwer skalierbar.

\subsection{Simulation urbaner Mobilität mit SUMO}

\textit{Simulation of Urban MObility} (SUMO) ist ein quelloffener, mikroskopischer Verkehrs-Simulator, der ursprünglich vom Deutschen Zentrum für Luft- und Raumfahrt (DLR) entwickelt wurde. SUMO erlaubt die detaillierte Modellierung individueller Fahrzeuge, Straßeninfrastruktur, Ampelschaltungen sowie Fahrverhalten.

Besonders relevant für diese Arbeit sind folgende Merkmale:

\begin{itemize}
    \item \textbf{Mikroskopische Modellierung:} Jedes Fahrzeug wird als individuelles Objekt simuliert. Parameter wie Geschwindigkeit, Abstand oder Spurwechselverhalten sind individuell konfigurierbar.
    \item \textbf{Flexible Netzdefinition:} Verkehrsnetze lassen sich aus OpenStreetMap-Daten sowie aus Shapefiles oder VISUM-Modellen mit dem Tool \texttt{netconvert} erzeugen. Netzdateien können auch mit \texttt{netedit} visuell editiert werden.
    \item \textbf{Nachfragegenerierung:} Fahrpläne und Routen lassen sich mit Tools wie \texttt{activitygen}, \texttt{randomTrips}, \texttt{od2trips} oder \texttt{duarouter} erzeugen – basierend auf statistischen oder echten OD-Matrizen.
    \item \textbf{Multimodalität:} SUMO unterstützt neben Pkw auch Busse, Fahrräder, Fußgänger sowie den öffentlichen Nahverkehr. Ampeln können für alle Verkehrsarten gleichzeitig modelliert werden.
    \item \textbf{Emissionsmodellierung:} Mit Hilfe von integrierten HBEFA-Tabellen (Version 4) kann SUMO CO\textsubscript{2}-, NO\textsubscript{x}- und Feinstaubemissionen simulieren und ausgeben.
    \item \textbf{Steuerbare Ampelanlagen:} Lichtsignalanlagen können sowohl mit festen Programmen als auch dynamisch über die TraCI-Schnittstelle gesteuert werden.
    \item \textbf{Reproduzierbarkeit und Kontrolle:} SUMO ist vollständig deterministisch, was es ideal für kontrollierte Experimente und das Training von KI-Agenten macht.
    \item \textbf{Visualisierung und Debugging:} Die SUMO-GUI und das Tool \texttt{sumo-gui} ermöglichen eine grafische Darstellung von Netz, Fahrzeugen, Ampelphasen und Simulationsergebnissen.
\end{itemize}

Die SUMO-Toolchain bietet damit alle notwendigen Komponenten für die Entwicklung, Analyse und Auswertung urbaner Verkehrsszenarien und stellt eine erprobte Plattform für KI-gestützte Steuerungsexperimente dar.

\subsection{Verstärkendes Lernen (Reinforcement Learning)}

Reinforcement Learning (RL) ist ein Teilgebiet des maschinellen Lernens, bei dem ein Agent durch Interaktion mit einer Umgebung lernt, optimale Handlungen auszuführen. Dabei verfolgt er das Ziel, eine kumulative Belohnung zu maximieren.

Ein RL-Prozess wird typischerweise als Markov Decision Process (MDP) beschrieben und besteht aus folgenden Komponenten:

\begin{itemize}
    \item \textbf{Zustand $s$ (state):} Eine Repräsentation der aktuellen Situation der Umgebung.
    \item \textbf{Aktion $a$ (action):} Eine Entscheidung oder Handlung, die der Agent im Zustand $s$ trifft.
    \item \textbf{Belohnung $r$ (reward):} Ein numerischer Wert, der die Güte der Aktion bewertet.
    \item \textbf{Policy $\pi$:} Eine Strategie, die angibt, welche Aktion in welchem Zustand gewählt wird.
\end{itemize}

Der Agent interagiert mit der Umgebung, beobachtet den Zustand, wählt eine Aktion, erhält eine Belohnung und gelangt in einen neuen Zustand. Durch viele Wiederholungen lernt er, welche Entscheidungen langfristig die besten sind.

Wichtige Algorithmen, die in dieser Arbeit potenziell relevant sind, sind:

\begin{itemize}
    \item \textbf{Q-Learning:} Modellfreies, off-policy Lernverfahren zur Annäherung an optimale Aktionen.
    \item \textbf{DQN (Deep Q-Network):} Kombination von Q-Learning mit neuronalen Netzen.
    \item \textbf{PPO (Proximal Policy Optimization):} Policy-basierter RL-Ansatz mit stabiler Optimierung.
\end{itemize}

\subsection{SUMO-RL: Architektur und Funktionalität}

\texttt{sumo-rl} ist ein Python-Framework, das SUMO mit Reinforcement Learning verbindet. Es basiert auf der \texttt{gymnasium}-Schnittstelle und abstrahiert typische Aufgaben wie die Definition von Beobachtungen, Aktionen und Belohnungen für RL-Agenten. Die Umgebung wird durch die Klasse \texttt{SumoEnvironment} bereitgestellt.

Zentrale Eigenschaften von \texttt{sumo-rl}:\cite{sumo-rl}

\begin{itemize}
    \item \textbf{TraCI-Integration:} Ermöglicht über das Traffic Control Interface zur Laufzeit den Zugriff auf Fahrzeugdaten, Ampelphasen, Fahrzeugwarteschlangen u.\,v.\,m.
    \item \textbf{Ein- und Mehragentenunterstützung:} \texttt{sumo-rl} unterstützt sowohl Single-Agent-Setups als auch Multi-Agent-Steuerung über die PettingZoo-API. Jeder gesteuerte Knoten im Netz kann einem eigenen Agenten zugewiesen werden.
    \item \textbf{Beobachtungen:} Die Umgebung liefert Beobachtungsvektoren mit kodierter Ampelphase, Rückstaulänge, Anzahl wartender Fahrzeuge und Fahrzeugdichte je Spur.
    \item \textbf{Aktionen:} Die Agenten treffen diskrete Entscheidungen über Phasenwechsel, wobei \texttt{delta\_time}, \texttt{yellow\_time} und \texttt{min\_green} die zeitliche Dynamik definieren.
    \item \textbf{Belohnungsfunktionen:} Der Standard-Reward basiert auf der Differenz kumulierter Wartezeiten. Eigene Funktionen können bei Initialisierung übergeben werden.
    \item \textbf{Kompatibilität:} Das Framework ist kompatibel mit Stable-Baselines3, PyTorch, TensorFlow, RLlib und anderen gängigen ML-Frameworks.
\end{itemize}

Beispielhafte Initialisierung:

\begin{verbatim}
env = SumoEnvironment(
    net_file='net.net.xml',
    route_file='routes.rou.xml',
    use_gui=True,
    reward_fn='diff-waiting-time',
    single_agent=True,
    delta_time=5,
    yellow_time=2,
    min_green=5
)
\end{verbatim}

\subsection{Verwandte Arbeiten}

In den letzten Jahren wurden zunehmend Studien veröffentlicht, die KI-Methoden zur Optimierung der Verkehrssteuerung einsetzen. Eine Auswahl relevanter Forschungsansätze:

\begin{itemize}
    \item \textbf{Wei et al. (2019):} Einsatz von Deep Q-Learning zur Optimierung einer einzelnen Ampel in SUMO mit signifikantem Rückgang der Wartezeiten \cite{wei2019}.
    \item \textbf{Chu et al. (2020):} Untersuchung von Multi-Agent-Ansätzen mit Deep RL zur Steuerung großflächiger Ampelnetze \cite{chu2020}.
    \item \textbf{Zheng et al. (2019):} Einführung eines Lernverfahrens zur Koordination konkurrierender Phasen bei Ampelsteuerungen mit Hilfe von SUMO \cite{zheng2019}.
\end{itemize}

Diese Arbeiten zeigen, dass RL-basierte Methoden das Potenzial haben, bestehende Systeme zu übertreffen – sowohl bei einfachen als auch bei komplexeren Szenarien. Die vorliegende Arbeit knüpft an diesen Forschungsstand an und erweitert ihn um eine Anwendung auf reale Geodaten aus Karlsruhe sowie eine methodische Evaluation.


\section{Datenquellen und Modellierungsgrundlage}

\subsection{OpenStreetMap als Grundlage für das Verkehrsmodell}

Das Verkehrsnetz für die Simulation basiert auf öffentlich verfügbaren Geodaten der Plattform OpenStreetMap (OSM). OSM bietet eine frei zugängliche, kollaborativ gepflegte Datenbank, die detaillierte Informationen zu Straßenverläufen, Kreuzungen, Fahrspuren, Tempolimits und teilweise zu Ampelanlagen enthält. Diese Eigenschaften machen OSM zu einer geeigneten Grundlage für mikroskopische Verkehrssimulationen mit SUMO.

Zur Erstellung des Netzes wurde ein Ausschnitt des Straßennetzes der Stadt Karlsruhe exportiert, der einen stark frequentierten urbanen Bereich mit mehreren signalgesteuerten Kreuzungen umfasst. Der betrachtete Bereich liegt zwischen 49{,}00738,\textdegree{}N und 49{,}01523,\textdegree{}N sowie 8{,}38589,\textdegree{}E und 8{,}40050,\textdegree{}E und deckt unter anderem die Reinhold-Frank-Straße, das Mühlburger Tor und angrenzende Hauptverkehrsachsen ab. Der Export erfolgte als \texttt{.osm}-Datei über den Geofabrik-Downloaddienst bzw. mit dem Tool JOSM. Die anschließende Konvertierung in das SUMO-Format erfolgte mit dem Programm \texttt{netconvert} (Version 1.19.0), einem Teil der SUMO-Toolchain. Hierbei wurden relevante Parameter wie Straßentypen, Fahrspuren, Prioritäten und erlaubte Abbiegevorgänge berücksichtigt. Als Typemap kam \texttt{osmNetconvert.typ.xml} zum Einsatz, um realitätsnahe Geschwindigkeiten und Fahrspuren zuzuweisen.

Das resultierende Verkehrsnetz umfasst 1.379 definierte Knotenpunkte (\textit{junctions}), 1.919 Straßenkanten (\textit{edges}) sowie insgesamt 5.310 modellierte Fahrstreifen (\textit{lanes}). Darüber hinaus konnten 17 signalgesteuerte Kreuzungen mit Lichtsignalanlagen (\textit{traffic lights}) identifiziert werden, die als Steuerungspunkte für das spätere Training der Reinforcement-Learning-Agenten dienen.

Optional wurden zusätzliche Informationen wie Ampeldefinitionen und Vorfahrtsregeln manuell über das Tool \texttt{netedit} ergänzt oder angepasst, um die Netzrealität weiter zu verfeinern. Dabei wurden insbesondere fehlerhafte Knotenbeziehungen bereinigt sowie isolierte Netzteile entfernt. Die finale \texttt{.net.xml}-Datei bildet die topologische und funktionale Grundlage für alle weiteren Simulationsschritte.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/karlsruhe_net.png}
\caption{Visualisierung des aus OSM generierten SUMO-Netzes (eigene Darstellung).}
\label{fig:sumo_network}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/karlsruhe_osm.png}
\caption{Screenshot des ursprünglichen OpenStreetMap-Ausschnitts (eigene Darstellung).}
\label{fig:osm_screenshot}
\end{figure}

Die Wahl von OpenStreetMap als Datenquelle gewährleistet eine offene, reproduzierbare und erweiterbare Modellierungsbasis. Jedoch bringt die Nutzung von OSM-Daten auch einige Einschränkungen mit sich, die bei der Modellierung berücksichtigt werden müssen:\cite{osm-export}

\begin{itemize}
\item \textbf{Uneinheitlicher Detaillierungsgrad:} Die Erfassungstiefe variiert regional stark, was dazu führt, dass z.\,B. Tempolimits, Fahrspuren oder Abbiegebeschränkungen an vielen Stellen fehlen oder unvollständig sind.
\item \textbf{Fehlende Ampel- und Signalsteuerungsdaten:} OSM enthält in der Regel keine vollständigen Angaben zu Ampelphasen, Umlaufzeiten oder koordinierter Schaltung. SUMO kann zwar aus heuristischen Annahmen Standardampeln generieren, diese weichen jedoch potenziell stark von der realen Steuerung ab.
\item \textbf{Keine garantierte Netzvollständigkeit:} Besonders kleinere Straßen, private Zufahrten oder temporäre Baustellen sind häufig nicht oder nur unzureichend erfasst. Zudem treten beim Zuschnitt von Kartenausschnitten an den Netzrändern regelmäßig unvollständige Knoten oder isolierte Kanten auf.
\item \textbf{Abweichende Modellierungskonzepte:} In OSM werden parallele Fahrbahnen oder getrennte Richtungsfahrbahnen oft als unabhängige Wege modelliert. Ohne geeignete Nachbearbeitung kann dies zu unnötigen Knoten und ineffizientem Verkehrsverhalten führen.
\item \textbf{Abhängig von Typemap- und Importoptionen:} Die Interpretation der OSM-Tags erfolgt in SUMO durch sogenannte Typemaps, die z.\,B. Tempolimits und Spuranzahl je nach Straßentyp zuweisen. Ohne geeignete Typemap kann das Verhalten nicht der Realität entsprechen.
\end{itemize}

\textbf{Fazit:} Insgesamt erlaubt OSM trotz dieser Limitationen den Aufbau eines funktionalen Verkehrsnetzes für mikroskopische Simulationen, sofern der Import sorgfältig konfiguriert und die resultierenden Daten kritisch hinterfragt und gegebenenfalls manuell nachbearbeitet werden.

\subsection{Verfügbare Verkehrsdaten}
Zur Kalibrierung und Validierung der Simulation sind verlässliche Verkehrsdaten unerlässlich. In Baden-Württemberg stehen hierfür mehrere öffentliche sowie kommerzielle Quellen zur Verfügung. Diese umfassen Informationen über Verkehrsstärken, Fahrzeugzusammensetzung, Reisezeiten und Störungen im Straßenverkehr. Im Folgenden werden die wichtigsten Quellen sowie die für das vorliegende Projekt relevanten Verkehrszählungen zusammengefasst.

\subsubsection{Öffentliche Datenquellen: LUBW, MobiData BW, Straßenverkehrszentrale, BASt}\cite{bast}
Die Landesanstalt für Umwelt Baden-Württemberg (LUBW) stellt aggregierte Verkehrszählungen im Rahmen automatischer Straßenverkehrszählungen bereit. Diese umfassen Tagesmittelwerte sowie jahreszeitliche Schwankungen für verschiedene Fahrzeugkategorien. Die Daten der Straßenverkehrszentrale Baden-Württemberg (SVZ-BW) liefern zudem Echtzeitinformationen zu Störungen, Baustellen und Verkehrsfluss.

Über die Plattform MobiData BW werden offene Mobilitätsdaten gebündelt bereitgestellt, darunter auch historische Detektordaten und OpenTraffic-Feeds. Die Bundesanstalt für Straßenwesen (BASt)\cite{bast} wiederum veröffentlicht bundesweite Zähldaten, insbesondere für überörtliche Straßen.

Diese öffentlichen Quellen bilden eine solide Grundlage für die realitätsnahe Modellierung des Verkehrsaufkommens, sind jedoch teilweise nur in aggregierter Form oder mit begrenzter räumlicher Auflösung verfügbar.

\subsubsection{Stationäre Zählstellen in Karlsruhe und Umgebung}
\label{sec:zaehlstellen-karlsruhe}
Eine besonders wertvolle Datenquelle zur realitätsnahen Modellierung des Verkehrsaufkommens stellen die stationären Zählstellen des Landes Baden-Württemberg dar. Diese liefern standardisierte Tagesverkehrswerte (DTV\footnote{DTV steht für \textit{Durchschnittlicher Tagesverkehr} und bezeichnet die mittlere Anzahl an Fahrzeugen, die einen bestimmten Straßenabschnitt pro Tag passieren – typischerweise gemittelt über einen längeren Zeitraum.}), getrennt nach Fahrzeugklassen.

\newpage
Im direkten Untersuchungsgebiet, der Reinhold-Frank-Straße in Karlsruhe, befindet sich eine automatische Dauerzählstelle. Die dort erfassten Werte für den Zeitraum vom 1.1. bis 20.6.2025 lauten:

\begin{itemize}
    \item \textbf{Kraftfahrzeuge (KFZ):} 21.300 Fahrzeuge/Tag
    \item \textbf{Personenkraftwagen (PKW):} 20.500 Fahrzeuge/Tag
    \item \textbf{Schwere Nutzfahrzeuge (sNfz):} 120 Fahrzeuge/Tag
\end{itemize}

Diese Messwerte stimmen gut mit den aus den äußeren Zufahrtsachsen abgeleiteten Schätzungen überein. Um das Verkehrsaufkommen plausibel zu quantifizieren, wurden zusätzlich acht zentrale Zählstellen aus dem Jahr 2023 entlang wichtiger Ein- und Ausfallstraßen berücksichtigt. Sie bilden die Grundlage für die Annahmen über den täglichen Verkehr, der potenziell durch das untersuchte innerstädtische Netz fließt:

\begin{table}[H]
\centering
\caption{Verkehrszählungen in und um Karlsruhe (DTV, Jahr 2023)}
\begin{tabular}{|l|l|r|r|r|}
\hline
\textbf{Zufahrt} & \textbf{Zählstellenbeschreibung} & \textbf{KFZ/Tag} & \textbf{SV/Tag} & \textbf{Gesamt} \\
\hline
B10 West & Rheinbrücke / Entenfang & 62.102 & 6.159 & 68.261 \\
B36 Neureut & Neureuter Str. / Ausfahrt Neureut Süd & 35.165 & 1.712 & 36.877 \\
B36 Nord & Eggenstein / Neureut & 28.595 & 1.361 & 29.956 \\
L605 Nord & Weißes Haus / Eggenstein & 14.563 & 220 & 14.783 \\
B36 Süd & Rheinstetten / Innenstadt & 24.239 & 1.487 & 25.726 \\
B36 Mörsch & Mörsch / Forchheim & 26.841 & 1.531 & 28.372 \\
L605 Süd & Ettlingen / Bulacher Kreuz & 65.816 & 3.474 & 69.290 \\
B10 Ost & Durlach (A5) / Innenstadt & 28.555 & 913 & 29.468 \\
\hline
\end{tabular}
\label{tab:zaehlstellen}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{images/zaehlstellenkarte.png}
\caption{Lage der Dauerzählstellen im Raum Karlsruhe (Quelle: MobiData BW \cite{mobidata_karte}).}
\label{fig:zaehlstellenkarte}
\end{figure}

Diese externen Zuflüsse liefern eine verlässliche Grundlage zur Generierung plausibler Eingangsrouten für Fahrzeuge in der Simulation. Das betrachtete Gebiet wird von mehreren dieser Hauptachsen direkt gespeist, wodurch sich ein realitätsnahes Verkehrsaufkommen im Bereich von 20.000–40.000 Fahrzeugen/Tag ergibt – im Einklang mit der Messung in der Reinhold-Frank-Straße.

Die Verwendung dieser Zähldaten ermöglicht es, Fahrzeugströme in SUMO proportional zu real beobachteten Verkehrsverhältnissen zu modellieren. Zudem erleichtert sie die spätere Kalibrierung und Validierung der simulierten Szenarien.

\subsubsection{Kommerzielle APIs: TomTom, Google Maps}\cite{googlemaps, tomtom}

Ergänzend zu den öffentlichen Datenquellen bieten kommerzielle Anbieter wie TomTom und Google über Programmierschnittstellen (APIs) hochaufgelöste Echtzeit- und Historikdaten an. Diese umfassen unter anderem:

\begin{itemize}
    \item Durchschnittliche Fahrgeschwindigkeiten nach Wochentag und Uhrzeit,
    \item Verkehrsdichte- und Stauinformationen,
    \item Prognosen basierend auf anonymisierten Bewegungsdaten.
\end{itemize}

Der Zugriff auf diese APIs ist in der Regel kostenpflichtig oder durch Nutzungsbeschränkungen limitiert, ermöglicht jedoch eine deutlich feinere zeitliche und räumliche Auflösung, was für die Modellierung und spätere Optimierung des Verkehrsflusses mittels KI von Vorteil ist.

\subsection{Modellierung der Ampelschaltungen}

Für eine realitätsnahe mikroskopische Simulation spielt die Modellierung der Lichtsignalsteuerung eine zentrale Rolle. Ampelanlagen beeinflussen maßgeblich den Verkehrsfluss an Knotenpunkten und sind daher ein zentraler Bestandteil der Simulationslogik.

\subsubsection{Verfügbare Daten und Herausforderungen}

In den öffentlich zugänglichen OSM-Daten sind Ampelanlagen in der Regel lediglich als Punktobjekte an Kreuzungen vermerkt. Informationen zu Phasenplänen, Umlaufzeiten oder koordinierter Schaltung fehlen vollständig. Auch von Seiten der Stadt Karlsruhe oder anderer kommunaler Stellen liegen keine detaillierten Steuerungsdaten vor, da diese in der Regel nicht öffentlich zugänglich sind.

Eine eigene systematische Erfassung der Schaltzeiten wäre zwar prinzipiell möglich, hätte jedoch einen erheblichen Zeitaufwand bedeutet und wäre aufgrund der dynamischen, nicht-statischen Signalsteuerungen (z.\,B. verkehrsabhängige Phasen) methodisch schwer zuverlässig umzusetzen gewesen.

\subsubsection{Vereinfachte Modellierung}

Aus diesen Gründen wurde auf eine synthetische Modellierung zurückgegriffen. SUMO bietet hierfür die Möglichkeit, sogenannte \texttt{tlLogic}-Blöcke manuell oder automatisch zu definieren, die verschiedene Phasenfolgen und Zeitparameter enthalten. In der vorliegenden Arbeit wurde auf Standardampelprogramme zurückgegriffen, wie sie in SUMO generisch verwendet werden, um zumindest eine vereinfachte Lichtsignalsteuerung zu modellieren. Diese erlaubt die spätere Untersuchung von Optimierungsstrategien mittels Reinforcement Learning, stellt jedoch keine Repräsentation der realen Signalprogramme dar.

\section{Methodik}

\subsection{Untersuchungsregion und Datenbasis}

\subsubsection{Auswahl der Untersuchungsregion}

Für die Anwendung und Evaluation der KI-basierten Verkehrssteuerung wurde ein Ausschnitt des innerstädtischen Straßennetzes von Karlsruhe gewählt. Die Auswahl fiel auf ein Gebiet rund um die Reinhold-Frank-Straße und das Mühlburger Tor, das durch hohe Verkehrsdichte, komplexe Knotenpunkte und mehrere signalgesteuerte Kreuzungen gekennzeichnet ist. Der gewählte Bereich liegt geografisch zwischen 49{,}006947\,\textdegree{}N und 49{,}015602\,\textdegree{}N sowie 8{,}380176\,\textdegree{}E und 8{,}403887\,\textdegree{}E und deckt mehrere stark frequentierte Hauptachsen ab.

Die Entscheidung für diese Region basiert auf folgenden Kriterien:

\begin{itemize}
    \item \textbf{Hohe Verkehrsbedeutung:} Das Gebiet stellt einen wichtigen innerstädtischen Verkehrsraum dar, der sowohl Pendlerverkehr als auch lokalen Individualverkehr aufnimmt.
    \item \textbf{Bekanntes Stauaufkommen:} Die Reinhold-Frank-Straße ist in der Stadtbevölkerung für regelmäßige Verkehrsstaus bekannt, insbesondere zu Stoßzeiten.
    \item \textbf{Verfügbarkeit realer Verkehrszähldaten:} Eine automatische Dauerzählstelle erhebt dort täglich Verkehrsdaten. Für den Zeitraum vom 1.1. bis 20.6.2025 wurden durchschnittlich 21.300 Kfz/Tag erfasst.
    \item \textbf{Zusätzliche Zähldaten angrenzender Hauptverkehrsstraßen:} Zählstellen an der B10, B36, L605 und in Durlach liefern ergänzende Werte zur Plausibilisierung des Gesamtverkehrsflusses.
    \item \textbf{Vorhandensein mehrerer Ampelanlagen:} Im Netz befinden sich 17 signalgesteuerte Kreuzungen, geeignet für RL-gesteuerte Steuerungsexperimente.
    \item \textbf{Gute Abgrenzbarkeit:} Das Gebiet ist topologisch geschlossen und in SUMO sauber simulierbar.
    \item \textbf{Verfügbarkeit von Geodaten:} Die Region ist in OpenStreetMap detailliert kartiert.
\end{itemize}

\subsubsection{Verfügbare Verkehrszähldaten}

Für die Kalibrierung und Validierung der Verkehrssimulation wurden verschiedene reale Zähldatenquellen aus dem Raum Karlsruhe herangezogen. Hauptquelle war dabei die offene Mobilitätsdatenplattform des Landes Baden-Württemberg (MobiData BW)\cite{mobidata_stunden}. Dort werden automatisiert erfasste Stundenwerte stationärer Dauerzählstellen veröffentlicht, die eine fein aufgelöste Analyse von Verkehrsverläufen ermöglichen.

Konkret wurden folgende Datensätze ausgewertet:

\begin{itemize}
    \item \textbf{Dauerzählstelle Reinhold-Frank-Straße:} Erfasst täglich die Anzahl der Kraftfahrzeuge (Kfz), aufgeschlüsselt nach Fahrzeugklassen (PKW, lNfz, sNfz). Für den Zeitraum 01.01.–20.06.2025 lag der durchschnittliche Tagesverkehr (DTV\footnote{DTV = durchschnittlicher Tagesverkehr: Durchschnittliche Anzahl an Fahrzeugen pro Tag über einen bestimmten Zeitraum hinweg.}) bei ca. 21.300 Kfz/Tag.
    
    \item \textbf{Historische Jahresmittelwerte:} Langzeitdatenreihen von 2008–2024 aus MobiData BW ermöglichen eine Kontextualisierung der aktuellen Verkehrsbelastung.

    \item \textbf{Zählstellen an äußeren Zufahrtsachsen:} Ergänzende Zähldaten aus dem Jahr 2023 an acht stark befahrenen Einfallstraßen (u.\,a. B10, B36, L605)\cite{mobidata_karte} liefern Anhaltspunkte zur Verkehrsstärke an den Netzrändern.
\end{itemize}

Die Kombination dieser Quellen ermöglicht eine robuste, datenbasierte Schätzung realistischer Flussverteilungen für die Simulation – sowohl zeitlich (z.\,B. Spitzenlasten) als auch räumlich (Zufahrtsverteilung).

\subsection{Aufbau des Simulationsmodells in SUMO}

\subsubsection{Netzgenerierung und Verkehrsflussmodellierung}

Zur Modellierung des realen Straßennetzes wurde ein Kartenausschnitt des Untersuchungsgebiets über die Exportfunktion von OpenStreetMap\cite{osm-export} heruntergeladen und anschließend mit JOSM\cite{josm} bearbeitet. Die Auswahl des Ausschnitts orientierte sich an der geografischen Abgrenzung rund um die Reinhold-Frank-Straße sowie die angrenzenden Hauptverkehrsachsen im Bereich des Mühlburger Tors. Der bereinigte Kartenausschnitt wurde anschließend mit dem SUMO-Werkzeug \texttt{netconvert}\cite{sumo-tools} in ein netzwerkkompatibles XML-Format überführt. Dabei kamen zusätzliche Optionen zur Verbesserung der Ampelmodellierung und Fahrstreifenzuordnung zum Einsatz (z.\,B. \texttt{--tls.guess-signals} und \texttt{--junctions.join}).

Die Erzeugung der Fahrzeugbewegungen erfolgte auf zwei Wegen: Zum einen wurden mit dem SUMO-Skript \texttt{randomTrips.py} initiale Testflüsse erzeugt, um die Simulation zu validieren. Zum anderen wurden auf Basis der analysierten Verkehrszähldaten realitätsnahe Flussprofile definiert, welche die beobachteten DTV-Werte auf die Randkanten des simulierten Netzes verteilen. Dabei wurde darauf geachtet, dass die Hauptverkehrsachsen wie die B10 oder B36 als primäre Zufahrtsrouten fungieren und mit einer höheren Fahrzeugdichte gewichtet werden.

Die resultierenden Routendateien wurden anschließend mit \texttt{duarouter} verarbeitet, um konfliktfreie Fahrten über das simulierte Netz zu erzeugen. Um unterschiedliche Verkehrssituationen abzubilden, wurden Szenarien mit variierender Verkehrsdichte simuliert – beispielsweise für Morgen- und Abendspitzen sowie für gleichmäßige Durchfahrtsverteilung.

Die erzeugten Flüsse orientieren sich dabei an der realen Kapazität der Knoten und Straßen und wurden mit Hilfe von Detektor-Ausgaben (u.\,a. \texttt{laneAreaDetector}) überprüft und bei Bedarf nachjustiert.

\subsubsection{Identifikation relevanter Zufahrtskanten}

Die Generierung realistischer Verkehrseinträge in das simulierte Netz basiert auf der systematischen Ermittlung geeigneter Zufahrtskanten. Diese stellen die äußeren Einfallstraßen dar, über die der Verkehr gemäß den Zähldaten in das Untersuchungsgebiet einfließt.

Zur Auswahl wurden zunächst bekannte Hauptverkehrsachsen wie die B10, B36, L605 oder die Durlacher Allee herangezogen. Anschließend erfolgte eine semiautomatische Zuordnung der SUMO-Kanten (\texttt{<edge>}) auf Basis der in OpenStreetMap vergebenen Straßennamen. Hierzu wurde ein Python-Skript eingesetzt, das alle Kanten mit einem \texttt{name}-Attribut durchsuchte und auf relevante Teilstrings prüfte (z.\,B. \texttt{"B10"}, \texttt{"Reinhold-Frank-Straße"}). Die Ergebnisse wurden manuell geprüft und bei Bedarf durch visuelle Kontrolle in \texttt{netedit} ergänzt.

Die so extrahierten Kanten wurden je Verkehrsachse gruppiert und bilden die Grundlage für die segmentierte Trip-Erzeugung.

\subsubsection{Automatisierte Generierung von Trips auf Basis realer Zählerdaten}

Zur Simulation realitätsnaher Verkehrsströme wurden die durchschnittlichen Tagesverkehre (DTV) aus Abschnitt~\ref{sec:zaehlstellen-karlsruhe} auf die jeweiligen Zufahrtsgruppen skaliert und anschließend auf die Simulationsdauer von 3600\,s verteilt. Ein eigens entwickeltes Python-Skript erzeugte aus diesen Daten Fahrzeugeinträge (\texttt{<trip>}), die mithilfe von \texttt{randomTrips.py} über die identifizierten Randkanten eingespielt wurden.

Die erzeugten Trips wurden im XML-Format gespeichert und anschließend mit \texttt{duarouter} zu vollständigen, konfliktfreien Routen (\texttt{<route>}) konvertiert. Die Gesamtanzahl und Verteilung der Fahrzeuge orientierte sich dabei an den stündlich extrapolierten DTV-Werten. Es wurde darauf geachtet, dass insbesondere stark belastete Zufahrten (z.\,B. B10, L605) mit höherem Gewicht berücksichtigt wurden.

\subsubsection{Visuelle und technische Validierung des Netzmodells}

Vor dem eigentlichen Einsatz des Modells wurde das gesamte Netz sowohl strukturell als auch funktional validiert. Die Prüfung erfolgte in mehreren Stufen:

\begin{itemize}
    \item \textbf{Netzprüfung:} Einsatz von \texttt{netconvert --check-lane-geometry} und \texttt{netcheck} zur Überprüfung der topologischen Konsistenz.
    \item \textbf{Visuelle Kontrolle:} Mit der SUMO-GUI sowie \texttt{netedit} wurden kritische Knoten visuell inspiziert, um Fehler wie unverbundene Spuren, widersprüchliche Geometrien oder falsche Richtungen zu identifizieren.
    \item \textbf{Manuelle Überprüfung aller TLS:} Jede einzelne Lichtsignalanlage wurde manuell in \texttt{netedit} geöffnet. Die Phasenpläne, gesteuerten Verbindungen und Zustandslängen (\texttt{state}) wurden dabei geprüft und bei Bedarf korrigiert.
\end{itemize}

Diese manuelle Validierung war äußerst zeitaufwändig, da fehlerhafte TLS nicht automatisch von SUMO erkannt werden. Die Identifikation von Problemen wie unpassenden \texttt{linkIndex}-Werten oder inkonsistenten Zustandslängen erforderte intensives Testen und systematisches Debugging. In mehreren Fällen mussten TLS-Definitionen komplett neu erstellt oder aufgelöst werden, was ein hohes Maß an Modellierungsverständnis und Geduld erforderte.

\subsubsection{Szenarien und Referenzsimulationen}

Zur Validierung der Verkehrsflüsse wurden unterschiedliche Simulationsszenarien implementiert:

\begin{itemize}
    \item \textbf{Morgenspitze (Rush Hour):} Verstärkte Einträge an den Süd- und Westzufahrten mit hoher Verkehrsdichte.
    \item \textbf{Abendliche Rückstaus:} Stärkere Belastung der Ausfallstraßen und des Innenstadtrings.
    \item \textbf{Gleichmäßiger Tagesverlauf:} Homogene Einträge mit ca. 1000 Fahrzeugen/h pro Richtung.
    \item \textbf{Zentrumsfokus:} Fokus auf Verkehrsströme über die Reinhold-Frank-Straße und das Mühlburger Tor.
\end{itemize}

Die resultierenden Simulationen dienten der Überprüfung der Netzdurchlässigkeit und der Validierung der physischen Kapazität der Kreuzungen. Dazu wurden Heatmaps, Fahrzeugzählungen sowie Detektor-Ausgaben (z.\,B. \texttt{laneAreaDetector}) ausgewertet. Die gewonnenen Erkenntnisse flossen in die finale Konfiguration der Flüsse und Phasenpläne ein.


\subsubsection{Signalsteuerung und Simulationsparameter}

Das untersuchte Verkehrsnetz umfasst insgesamt 17 signalgesteuerte Kreuzungen. Diese wurden aus dem OpenStreetMap-Datensatz automatisch erkannt und im Rahmen der Netzkonvertierung mit \texttt{netconvert} anhand der Option \texttt{--tls.guess-signals} initial als Lichtsignalanlagen (Traffic Light Systems, TLS) modelliert. Die generierten Ampelphasen wurden anschließend manuell überprüft und bei Bedarf über die mit SUMO mitgelieferte GUI \texttt{netedit} angepasst.

Für die initiale Simulation wurde eine feste Phasenlogik (fixed-time control) verwendet, um ein Grundverhalten zu etablieren. Dabei erhielten alle Kreuzungen definierte Signalphasen mit festen Umlaufzeiten zwischen 30 und 60 Sekunden, abhängig von der Knotentopologie. Zur Vorbereitung des Reinforcement-Learning-Trainings wurden alle relevanten Kreuzungen so konfiguriert, dass sie in SUMO als „aktuiert“ geschaltet werden konnten. Dies ist erforderlich, damit die Steuerung durch externe Agenten via \texttt{TraCI} möglich ist.

Die Simulation wurde mit folgenden Parametern durchgeführt:

\begin{itemize}
    \item \textbf{Simulationszeitraum:} 3600 Sekunden (entspricht 1 Stunde Echtzeit)
    \item \textbf{Zeitschritt (step-length):} 1,0 s
    \item \textbf{Routengenerierung:} deterministisch mit fixer seed zur Reproduzierbarkeit
    \item \textbf{Simulationstyp:} \texttt{meso}-Modus zur Beschleunigung des Trainings (später auch \texttt{default}-Modus für Evaluation)
    \item \textbf{Verkehrsverteilung:} über \texttt{flows.xml} definiert und über Randkanten eingeleitet
\end{itemize}

Die Definition und Verwaltung der TLS-Systeme erfolgt in separaten Dateien (\texttt{*.add.xml}), welche in der SUMO-Konfigurationsdatei eingebunden werden. Für die spätere Anbindung an das Reinforcement-Learning-Modul wurden alle zu steuernden Ampelanlagen mit eindeutigen IDs versehen und überprüft.

\subsection{Reinforcement-Learning-Konzept}
\subsubsection{Formulierung des RL-Problems}
Das Problem der Verkehrssteuerung wird als sequentielles Entscheidungsproblem modelliert und mit Hilfe von Reinforcement Learning (RL) gelöst. Ziel ist es, einen Agenten zu trainieren, der durch geeignete Steuerung der Ampelphasen den Verkehrsfluss optimiert. Die Umgebung besteht aus dem simulierten Straßennetz, wie es in SUMO definiert ist. Die Interaktion erfolgt über das TraCI-Interface, das eine Laufzeitsteuerung der Ampelanlagen erlaubt.
\paragraph{Zustände}

Der Zustand \( s_t \) eines Reinforcement-Learning-Agenten beschreibt die Verkehrssituation an einer einzelnen Kreuzung zum Zeitpunkt \( t \). Ziel ist es, dem Agenten ausreichend Informationen über den lokalen Verkehrsfluss zur Verfügung zu stellen, damit er fundierte Entscheidungen über die Steuerung der Lichtsignalanlage treffen kann.

Die Zustandsrepräsentation basiert auf den folgenden Komponenten:

\begin{itemize}
    \item \textbf{Fahrzeuganzahl pro Zufahrtsspur:} Für jede dem Knoten zuführende Fahrspur wird die aktuelle Anzahl an Fahrzeugen ermittelt. Dies geschieht über sogenannte \texttt{laneAreaDetector}, die für jede Spur individuell in SUMO definiert werden. Die Werte werden periodisch über \texttt{TraCI} abgefragt.
    
    \item \textbf{Warteschlangenlänge (queue length):} Gibt die Anzahl der Fahrzeuge an, die sich auf einer Spur mit Geschwindigkeit \texttt{< 0.1 m/s} befinden. Dies ist ein wichtiges Maß für Rückstaus an Kreuzungen.
    
    \item \textbf{Durchschnittliche Geschwindigkeit pro Spur:} Diese Kenngröße erlaubt Rückschlüsse auf den Verkehrsfluss pro Richtung und ergänzt die reine Anzahlinformation. 
    
    \item \textbf{Ampelphase (TLS state):} Die aktuell geschaltete Ampelphase wird als diskrete Phase kodiert (z.\,B. 0, 1, 2, ...). In SUMO entspricht dies der Index der aktiven Phase im Phasenplan der TLS.
    
    \item \textbf{Dauer der aktuellen Phase:} Die Anzahl der Zeitschritte seit Beginn der aktuellen Phase. Diese Information ist notwendig, um Phasenlängen sinnvoll zu steuern (z.\,B. Mindestgrünzeit).
    
    \item \textbf{Binärmasken zur Phasenwechselbarkeit:} Kodierung, ob ein Wechsel zur nächsten Phase gemäß Übergangsbedingungen (z.\,B. Mindestgrünzeit) aktuell möglich ist. Diese Information ist erforderlich, falls das Aktionsmodell auch direkte Sprünge zwischen nicht direkt benachbarten Phasen erlaubt.
    
    \item \textbf{Optional – Nachbarschaftszustand:} In Multi-Agent-Settings kann es sinnvoll sein, zusätzlich aggregierte Zustandsinformationen benachbarter Knoten einzubeziehen (z.\,B. Gesamtwarteschlange auf ausgehenden Spuren, die zu benachbarten TLS führen).
\end{itemize}

Die Zustände werden zu einem normierten Merkmalsvektor kombiniert und bilden damit die Eingabe für das neuronale Entscheidungsmodell des Agenten.

\paragraph{Aktionen}

Die Aktionsmenge \( A \) eines Agenten beschreibt die Eingriffsmöglichkeiten in den Steuerungsablauf der jeweiligen Ampelkreuzung. Dabei wird zwischen zwei gängigen Aktionsmodellen unterschieden:

\begin{enumerate}
    \item \textbf{Phasenwechsel-Modell:} Der Agent entscheidet, ob die aktuelle Phase fortgesetzt oder zur nächsten gewechselt werden soll. Es handelt sich um ein binäres Aktionsmodell:
    \[
    A = \{ \texttt{keep},\ \texttt{switch} \}
    \]
    Diese Variante wird häufig in klassischen SUMO-RL-Implementierungen verwendet (z.\,B. `sumo-rl`). Die Reihenfolge der Phasen ist dabei festgelegt (z.\,B. zyklischer Übergang).
    
    \item \textbf{Direktwahl-Modell:} Der Agent wählt direkt aus allen möglichen Phasen die nächste aus:
    \[
    A = \{ \texttt{phase}_0,\ \texttt{phase}_1,\ \ldots,\ \texttt{phase}_n \}
    \]
    Diese Variante erfordert eine eigene Definition der Übergangslogik in SUMO (z.\,B. über permissive TLS-Ketten), erlaubt aber größere Flexibilität und exploratives Verhalten.
\end{enumerate}

Unabhängig vom Modell gelten folgende Einschränkungen:

\begin{itemize}
    \item \textbf{Mindestgrünzeiten:} Ein Wechsel der Phase darf erst nach einer definierten Mindestgrünzeit erfolgen (z.\,B. 5 s), um realistische Signalisierung und Verkehrssicherheit zu gewährleisten.
    
    \item \textbf{Sicherheitsbedingte Zwischenphasen:} SUMO erzwingt automatisch Zwischenphasen wie Gelb- oder Räumzeiten. Der Agent gibt nur den Phasenwunsch an, die exakte Ablaufsteuerung erfolgt durch das TLS-Modell in SUMO.
    
    \item \textbf{Simultane Agentenentscheidung:} Bei mehreren Knoten wird jeder TLS-Agent unabhängig gesteuert, es sei denn, ein zentrales Multi-Agent-Training wird implementiert.
\end{itemize}

Zur Reduktion der Aktionsfrequenz wird häufig ein sogenanntes \textbf{Action Interval} festgelegt (z.\,B. alle 5 s), sodass Entscheidungen nur in bestimmten Zeitschritten getroffen werden können. Dies verhindert zu hektisches Umschalten der Ampeln.

\paragraph{Belohnungsfunktion}

Die Belohnungsfunktion ist zentrales Element des Lernprozesses und bestimmt das Optimierungsziel. Sie wurde so gestaltet, dass sie folgende Aspekte negativ gewichtet:

\begin{itemize}
    \item \textbf{Gesamte Wartezeit aller Fahrzeuge} (minimieren)
    \item \textbf{Länge der Fahrzeugschlangen} (minimieren)
    \item \textbf{Anzahl der Stopps} (minimieren)
\end{itemize}

Die konkrete Belohnung \( r_t \) zum Zeitpunkt \( t \) berechnet sich nach:

\[
r_t = -\alpha \cdot \sum_{\text{alle Spuren}} \text{queueLength}_i(t) - \beta \cdot \sum_{\text{alle Fahrzeuge}} \text{waitingTime}_j(t)
\]

wobei \( \alpha \) und \( \beta \) Gewichtungsfaktoren darstellen, die im Rahmen der Hyperparameteroptimierung bestimmt werden. In späteren Varianten kann die Belohnung durch zusätzliche Komponenten wie Emissionen oder Energieverbrauch ergänzt werden, um umweltfreundliche Steuerungsstrategien zu fördern.

\subsection{Analyse und Herausforderungen bei der OSM-Netznutzung}


\subsubsection{Grundstruktur von Lichtsignalanlagen (TLS) in SUMO}
Bevor die Probleme beim OSM-Import analysiert werden, ist es hilfreich, den Aufbau und die Abhängigkeiten der relevanten XML-Elemente in SUMO zu verstehen, insbesondere im Zusammenhang mit der Steuerung von Lichtsignalanlagen (\textit{Traffic Light Systems, TLS}).

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/junktion.png}
\caption{Visualisierung einer TLS-Kreuzung (eigene Darstellung).}
\label{fig:sumo_karlsruhe}
\end{figure}

\begin{itemize}
    \item \textbf{\texttt{<junction>}} – Definiert Knotenpunkte im Netz. Falls eine Ampel gesteuert wird, ist der Typ \texttt{type="traffic\_light"}. Die ID entspricht in der Regel der TLS-ID.
    
    \item \textbf{\texttt{<connection>}} – Verbindet zwei Fahrstreifen (von \texttt{from} nach \texttt{to}). Wenn diese Verbindung durch eine Ampel kontrolliert wird, enthält sie die Attribute \texttt{tl="<tls\_id>"} und \texttt{linkIndex}. Die Reihenfolge der \texttt{linkIndex}-Werte bestimmt die Position im Phasen-String.
    
    \item \textbf{Controlled Link} – Jede \texttt{<connection>} mit einem \texttt{tl}-Attribut zählt als „gesteuerte Verbindung“. Die Anzahl solcher Verbindungen bestimmt die Länge des Phasenstrings (\texttt{state}).
    
    \item \textbf{\texttt{<tlLogic>}} – Enthält die Steuerungslogik einer TLS. Jede \texttt{<tlLogic>} hat eine eindeutige ID (i.d.R. identisch zur \texttt{junction}-ID) und eine Liste von \texttt{<phase>}-Elementen.
    
    \item \textbf{\texttt{<phase>}} – Jede Phase ist ein String (z.B. \texttt{"Grgr"}), der den Zustand aller \texttt{linkIndex}-Verbindungen kodiert. Jeder Buchstabe (z.B. G = Grün, r = Rot) steht für den Status eines bestimmten kontrollierten Links.
    
    \item \textbf{\texttt{<request>}} – Optionale Anforderungen einzelner Signalgruppen, meist bei aktuierten oder adaptiven TLS. Jeder Eintrag verweist über \texttt{index=} auf einen gesteuerten Link.
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  font=\small,
  node distance=1.2cm and 3cm,
  every node/.style={align=center},
  box/.style={draw, rounded corners, minimum width=3.2cm, minimum height=1cm}
]

% Hauptknoten
\node[box] (junction) {\texttt{<junction>}\\ID = J1};
\node[box, right=4.5cm of junction] (tlLogic) {\texttt{<tlLogic>}\\ID = J1};

% Verbindungen unterhalb
\node[box, below left=1.7cm and 0.4cm of junction] (conn1) {\texttt{<connection>}\\\texttt{linkIndex=0}};
\node[box, below right=1.7cm and 0.4cm of junction] (conn2) {\texttt{<connection>}\\\texttt{linkIndex=1}};

% Phase
\node[box, below right=1.7cm and 0.4cm of conn1] (phase) {\texttt{<phase>}\\\texttt{state="Gr"}};

% Kanten
\draw[->] (junction.east) -- node[above] {\texttt{tl="J1"}} (tlLogic.west);
\draw[->] (junction.south west) -- (conn1.north);
\draw[->] (junction.south east) -- (conn2.north);
\draw[->] (conn1.south) -- ([xshift=-0.8cm]phase.north);
\draw[->] (conn2.south) -- ([xshift=+0.8cm]phase.north);

\end{tikzpicture}
\caption{Zusammenspiel von Kreuzung, Verbindungen und Ampellogik in SUMO}
\label{fig:tls_structure}
\end{figure}


\subsubsection{Typische Fehlerquellen nach OSM-Import}

Die automatische Ableitung von Ampelsteuerungen aus OSM ist unvollständig und fehleranfällig. Im Zusammenspiel mit \texttt{sumo-rl} ergeben sich daraus mehrere konkrete Probleme:

\begin{itemize}
    \item \textbf{Fehlende oder unvollständige TLS-Definitionen:} In OSM sind Ampelanlagen in der Regel lediglich als Punktknoten mit dem Tag \texttt{highway=traffic\_signals} erfasst. Die genaue Schaltlogik (\texttt{tlLogic}) – inklusive Phasen und Zustände – fehlt vollständig. SUMO generiert daher beim Netzimport mit \texttt{--tls.guess-signals} heuristische Ampeldefinitionen, die jedoch oft lückenhaft oder unbrauchbar sind.
    
    \item \textbf{TLS mit nur einer Phase:} Viele der generierten Ampeln besitzen lediglich eine einzige definierte Phase. Dies entspricht keinem realen Verhalten und führt zu Fehlern beim Training mit \texttt{sumo-rl}, da das Framework mindestens zwei steuerbare Phasen voraussetzt. Die betroffenen Knoten müssen daher identifiziert und aus der Simulation ausgeschlossen oder manuell korrigiert werden.
    
    \item \textbf{Unstimmige Phasenlängen:} Jede Phase in SUMO ist ein Zeichenstring (\texttt{state}), dessen Länge der Anzahl der gesteuerten Verbindungen (sogenannte \textit{controlled links}) entsprechen muss. Bei fehlerhafter Generierung ist diese Bedingung oft verletzt – etwa wenn der \texttt{state} zu kurz oder zu lang ist. Dies führt in \texttt{sumo-rl} zu Indexfehlern oder undefiniertem Verhalten.
    
    \item \textbf{Fehlerhafte oder überzählige \texttt{<request>}-Einträge:} Jede TLS enthält in der Netzdatei zusätzliche Steuerinformationen über \texttt{request}-Elemente. Diese verweisen auf spezifische Signale mittels eines Index. Häufig verweisen diese Einträge jedoch auf nicht vorhandene Verbindungen, da \texttt{netconvert} Signalverknüpfungen nicht korrekt zuordnet. SUMO ignoriert solche Fehler teilweise still – \texttt{sumo-rl} hingegen bricht mit Ausnahmen ab.
    
    \item \textbf{Mehrdeutige oder verschachtelte Kreuzungen:} In komplexeren innerstädtischen Kreuzungen fasst SUMO mehrere OSM-Knoten zu einem „cluster“ zusammen, um den Verkehrsfluss abzubilden. Dies kann zu sehr großen TLS mit dutzenden Ein- und Ausfahrten führen, die übermäßig viele Phasen oder extrem lange Zustandsdefinitionen erzeugen. Solche TLS sind schwer zu debuggen und häufig inkompatibel mit den Erwartungen von \texttt{sumo-rl}.
\end{itemize}

\paragraph{Folgen für \texttt{sumo-rl}}

Das Framework \texttt{sumo-rl} erwartet für jede zu steuernde TLS:

\begin{itemize}
    \item mindestens zwei valide Phasen,
    \item konsistente Phasenzustände (\texttt{state}) mit korrekter Länge,
    \item vollständige Verbindungen zu kontrollierten Links,
    \item eindeutig identifizierbare TLS-IDs.
\end{itemize}

Sind diese Anforderungen nicht erfüllt, führt dies typischerweise zu einer der folgenden Fehlermeldungen:

\begin{itemize}
    \item \texttt{IndexError: string index out of range}
    \item \texttt{ValueError: Invalid phase length}
    \item \texttt{KeyError: TLS not found}
\end{itemize}

Da diese Probleme nicht durch SUMO selbst gemeldet, sondern erst zur Laufzeit in \texttt{sumo-rl} sichtbar werden, ist ein systematischer Debugging- und Reparaturprozess zwingend notwendig. Die Komplexität steigt dabei exponentiell mit der Anzahl der TLS im Netz.

\paragraph{Erkenntnis}

Der direkte Import von OSM-Daten in SUMO erzeugt ein formal nutzbares Netz – jedoch nicht automatisch ein für Reinforcement Learning geeignetes. Ohne zusätzliche Aufbereitung ist ein stabiler Trainingsbetrieb in \texttt{sumo-rl} nicht möglich. Deshalb wurden im Rahmen dieser Arbeit eigene Tools zur automatisierten Analyse und Reparatur des Netzes entwickelt, die im folgenden Abschnitt näher beschrieben werden.

\subsubsection{Problematik nicht-motorisierter Verkehrswege im OSM-Modell}

Ein besonders gravierendes Problem beim OSM-Import waren die Strukturen nicht-motorisierter Verkehrsträger – vor allem Fußwege, Überwege und Fahrradtrassen. Diese sind im OSM-Datenmodell oft detailliert, aber aus simulationslogischer Sicht problematisch integriert:

\begin{itemize}
    \item \textbf{Separate Fahrspuren für Radverkehr:} Diese führen zu zusätzlichen Fahrstreifen mit eigenen Abbiegebeziehungen, die SUMO automatisch als kontrollierungsbedürftig klassifiziert. Häufig entstehen dadurch extrem lange TLS-Zustände mit über 50 Signalgruppen.
    
    \item \textbf{Fußgängerüberwege mit Konfliktzonen:} Viele \texttt{highway=crossing}-Elemente erzeugen automatisierte Verbindungen in SUMO, die mit Ampelphasen abgesichert werden müssen – selbst wenn sie im Originalnetz rein logisch sind. Dies bläht die Netzstruktur zusätzlich auf.
    
    \item \textbf{Entfernung kaum möglich:} Ein gezieltes Entfernen nicht-motorisierter Wege führt zu inkonsistenten Junctions, zerrissenen Knotenverbindungen und Netzfragmentierung. Eine selektive Bereinigung dieser Elemente hätte manuell erfolgen müssen – mit hohem Fehlerpotenzial.
\end{itemize}

Diese Phänomene führten letztlich zu der Entscheidung, auf eine synthetische Umgebung umzusteigen, in der alle Verkehrsteilnehmer und Verkehrsbeziehungen explizit und gezielt modelliert werden können.


\subsubsection{Eingesetzte \texttt{netconvert}-Optionen und deren Grenzen}

Im Rahmen der Netzgenerierung wurden zahlreiche Optionen des SUMO-Tools \texttt{netconvert} genutzt, um die aus OSM exportierten Daten zu verbessern und automatisiert für die Simulation aufzubereiten. Dabei kamen insbesondere folgende Konvertierungsoptionen zum Einsatz:

\begin{itemize}
    \item \texttt{--tls.guess-signals}: Automatische Erkennung und Erzeugung von Ampelanlagen basierend auf der Netzstruktur und OSM-Tags. Zwar werden damit grundlegend steuerbare TLS erstellt, jedoch mit oft unrealistischen Phasenkombinationen oder lediglich einer einzigen Phase – was im Kontext von \texttt{sumo-rl} unbrauchbar ist.

    \item \texttt{--tls.join}: Versucht, benachbarte Ampelanlagen zu einer gemeinsamen Steuerungseinheit zu verschmelzen. Dies führte in der Praxis zu unübersichtlichen und kaum nachvollziehbaren TLS-Clustern mit dutzenden Signalgruppen, die sich weder debuggen noch sinnvoll manuell reparieren ließen.

    \item \texttt{--junctions.join}: Fügt benachbarte Knotenpunkte zusammen, um komplexe Kreuzungen zu vereinfachen. In der Umsetzung erzeugt diese Option allerdings häufig übermäßig große Junction-Cluster mit einer Vielzahl von Ein- und Ausfahrten. Die daraus resultierenden Junctions waren nicht mehr sinnvoll steuerbar.

    \item \texttt{--ramps.guess}: Wird bei Autobahnimporten verwendet, um Ein- und Ausfahrten korrekt zu erkennen. In urbanen Netzen wie dem Karlsruher Modell zeigte diese Option jedoch keine spürbare Verbesserung oder sogar fehlerhafte Zuweisungen von Abbiegebeziehungen.

    \item \texttt{--remove-edges.isolated} und \texttt{--keep-edges.by-vclass}: Weitere Optionen zur Bereinigung überflüssiger oder nicht-kfz-tauglicher Straßenabschnitte zeigten nur begrenzte Wirkung, da viele Fuß- und Radverbindungen dennoch als relevante Kanten im Netz verblieben.

    \item \texttt{--discard-simple}: Entfernt automatisch alle einfachen Kreuzungen (d.\,h. Knoten mit nur zwei verbundenen Kanten) aus dem Netz. Ziel ist es, das Netz zu vereinfachen und unnötige Zwischenknoten zu reduzieren. In der Praxis zeigte sich jedoch, dass durch diese Option auch technisch relevante Einmündungen und Übergänge entfernt wurden, was zu fehlerhaften Verbindungen oder fehlenden Ampelanlagen führte. Darüber hinaus erschwert die Option eine saubere Reproduktion der realen Verkehrsführung, da sie die Netztopologie unkontrollierbar verändert.

\end{itemize}

Obwohl diese Optionen teilweise strukturelle Verbesserungen erzielen konnten, blieben die generierten Netze in ihrer Gesamtheit unzuverlässig: entweder zu komplex, unvollständig, inkonsistent oder inkompatibel mit dem Reinforcement-Learning-Framework. Auch die Kombination mehrerer Optionen führte oft zu unvorhersehbaren Seiteneffekten – etwa widersprüchlichen TLS-Zuständen oder unvollständig verbundenen Junctions. 

Die automatisierten Heuristiken von \texttt{netconvert} sind auf generische OSM-Netze ausgelegt, nicht jedoch auf die hohen Anforderungen an Konsistenz, Steuerbarkeit und Reproduzierbarkeit, wie sie ein RL-basiertes Trainingsumfeld erfordert.

\subsubsection{Grenzen der OSM-basierten Netzmodellierung}

Trotz erheblicher Anstrengungen bei der Bereinigung und Validierung des OSM-basierten Karlsruher Verkehrsnetzes erwiesen sich einige strukturelle Einschränkungen als nicht zuverlässig behebbar. Insbesondere die starke Präsenz und topologische Einbindung von Fuß- und Radverkehrswegen führte zu nachhaltigen Problemen im Modell:

\begin{itemize}
    \item \textbf{Übermäßige Knotenvernetzung:} Fuß- und Radwege erzeugen eine Vielzahl zusätzlicher Knoten und Verbindungen, die beim Import aus OSM oft zu komplex verschachtelten Kreuzungsclustern führen. Diese lassen sich weder zuverlässig entwirren noch stabil mit funktionalen TLS versehen.
    
    \item \textbf{Unkontrollierbare Verbindungsstruktur:} Beim Versuch, Fuß- und Radverbindungen selektiv aus dem Netz zu entfernen, entstehen häufig inkonsistente oder gar fehlerhafte Verbindungen zwischen verbleibenden Fahrbahnen. Dies führt zu nicht steuerbaren Junctions, überzähligen Abbiegebeziehungen und unbrauchbaren Ampelschaltungen.

    \item \textbf{Unvereinbarkeit mit RL-Steuerung:} Selbst nach umfangreicher Reparatur verbleiben viele Knoten, die strukturell oder logisch nicht mit \texttt{sumo-rl} kompatibel sind. Die dafür nötigen manuellen Eingriffe überschreiten den praktikablen Aufwand für ein robustes, reproduzierbares Modell.
\end{itemize}

\subsubsection{Übergang zu einem synthetischen Verkehrsnetz}

Nach mehreren Iterationszyklen wurde daher entschieden, den Fokus dieser Arbeit auf ein \textbf{synthetisch generiertes Verkehrsnetz} zu verlagern. Dieses basiert nicht auf realen Geodaten, sondern wird gezielt so konstruiert, dass es die Anforderungen an eine kontrollierte Umgebung für das Training von Reinforcement-Learning-Agenten erfüllt:

\begin{itemize}
    \item \textbf{Reduzierte Komplexität bei hoher Steuerbarkeit:} Das generierte Netz vermeidet absichtlich komplexe Kreuzungstopologien und erlaubt gezielte Definition steuerbarer TLS.
    
    \item \textbf{Fehlerresistenz und Modularität:} Durch vollständige Kontrolle über Struktur, Phasenpläne und Verkehrsverteilung ist eine konsistente und wiederholbare Simulation möglich.
    
    \item \textbf{RL-geeignete Gestaltung:} Alle im Netz enthaltenen Kreuzungen sind mit mindestens zwei sinnvollen Ampelphasen modelliert, beinhalten konsistente Signaldefinitionen und erfüllen die technischen Anforderungen von \texttt{sumo-rl}.
\end{itemize}

Der Einsatz des synthetischen Netzes ermöglicht es, sich auf die eigentliche Forschungsfrage – die Optimierung von Ampelsteuerung durch RL – zu konzentrieren, ohne durch externe Störfaktoren behindert zu werden. Die im vorigen Abschnitt dokumentierten Schritte bleiben dennoch ein zentraler Bestandteil dieser Arbeit, da sie den praktischen Aufwand und die Limitationen realer OSM-Netze in SUMO transparent machen.

\subsection{Netzprüfung, Reparatur und Toolchain}
Aufgrund der oben beschriebenen strukturellen Schwächen im importierten OSM-Netz war eine manuelle Nachbearbeitung ineffizient und fehleranfällig. Daher wurden eigene Werkzeuge entwickelt, um eine systematische und automatisierte Reparatur zu ermöglichen.


\subsubsection{Werkzeuge zur Netzprüfung und Reparatur}

Um die Kompatibilität des aus OpenStreetMap abgeleiteten Verkehrsnetzes mit \texttt{sumo-rl} sicherzustellen, wurde eine Reihe eigenentwickelter Python-Skripte implementiert. Diese Werkzeuge automatisieren die Analyse, Validierung und Korrektur der Netzstruktur mit Fokus auf Lichtsignalanlagen (TLS). Der modulare Aufbau erlaubt es, problematische Netzbestandteile zu identifizieren und gezielt zu bereinigen.

\paragraph{Prüfung der Signalverknüpfungen und Zustandslängen}

Zwei zentrale Tools wurden entwickelt, um die Konsistenz zwischen kontrollierten Verbindungen (\textit{controlled links}) und Phasenzuständen (\texttt{state}) der TLS zu überprüfen:

\begin{itemize}
    \item \textbf{\texttt{check\_tls\_consistency.py}} prüft, ob die Länge jedes \texttt{state}-Strings in den \texttt{<phase>}-Elementen exakt der Anzahl der gesteuerten Signalindizes entspricht. Abweichungen werden detailliert gelistet, inklusive betroffener Phase und TLS-ID.
        
        \begin{algorithm}[H]
        \caption{CheckTLSLengths – Prüfung inkonsistenter Phasenlängen}
        \begin{algorithmic}[1]
        \Function{CheckTLSLengths}{net.xml}
          \State Lade XML-Baum und extrahiere \texttt{<connection>}-Elemente
          \State Erstelle Dictionary \texttt{tls\_controlled\_links} mit Anzahl gesteuerter Links pro TLS
          \ForAll{\texttt{tlLogic}-Elemente im Netz}
            \State \texttt{expectedLen} $\gets$ Anzahl \texttt{controlledLinks} aus Dictionary
            \If{\texttt{expectedLen} = 0}
              \State Gib Warnung: TLS hat keine gesteuerten Verbindungen
              \State \textbf{continue}
            \EndIf
            \ForAll{Phasen $i$ in \texttt{tlLogic}}
              \State \texttt{actualLen} $\gets$ Länge des \texttt{state}-Strings
              \If{\texttt{actualLen} $\neq$ \texttt{expectedLen}}
                \State Gib Warnung mit TLS-ID, Phase und \texttt{state}-Inhalt aus
              \EndIf
            \EndFor
          \EndFor
          \If{keine Abweichungen gefunden}
            \State Gib Erfolgsmeldung aus
          \EndIf
        \EndFunction
        \end{algorithmic}
        \end{algorithm}
        
        \newpage
\noindent
\textbf{Originalcode in Python (\texttt{check\_tls\_consistency.py}):}

\begin{minted}[fontsize=\small, linenos, frame=lines, breaklines, tabsize=4]{python}
import xml.etree.ElementTree as ET

# === Konfiguration ===
net_file = "karlsruhe.net.xml"

# === Einlesen ===
tree = ET.parse(net_file)
root = tree.getroot()

# === Alle controlledLinks zählen ===
tls_controlled_links = {}
for connection in root.findall("connection"):
    if "tl" in connection.attrib and "linkIndex" in connection.attrib:
        tls_id = connection.attrib["tl"]
        tls_controlled_links.setdefault(tls_id, set()).add(int(connection.attrib["linkIndex"]))

# === Alle Phasen prüfen ===
def check_tls_lengths():
    print("Überprüfe alle TLS auf inkonsistente Phasenlängen...\n")
    any_issues = False
    for logic in root.findall("tlLogic"):
        tls_id = logic.attrib["id"]
        expected_len = len(tls_controlled_links.get(tls_id, []))

        if expected_len == 0:
            print(f" TLS '{tls_id}' hat keine controlledLinks (wird evtl. nicht gesteuert)")
            continue

        for i, phase in enumerate(logic.findall("phase")):
            actual_len = len(phase.attrib["state"])
            if actual_len != expected_len:
                print(f" Phase {i} von TLS '{tls_id}' hat Länge {actual_len}, erwartet: {expected_len}")
                print(f"    → state=\"{phase.attrib['state']}\"")
                any_issues = True

    if not any_issues:
        print(" Alle TLS-Phasen stimmen mit ihren controlledLinks überein!")

check_tls_lengths()
\end{minted}

    \newpage
    \item \textbf{\texttt{check\_tls\_requests.py}} validiert, ob alle \texttt{<request>}-Indizes innerhalb zulässiger Grenzen liegen. Falsch verknüpfte Einträge – z.\,B. \texttt{index > max(signalIndex)} – werden gemeldet.

    \begin{algorithm}[H]
    \caption{CheckTLSRequests – Prüfung ungültiger \texttt{request}-Indizes}
    \begin{algorithmic}[1]
    \Function{CheckTLSRequests}{net.xml}
      \State Lade XML-Datei und parse Wurzelknoten
      \State Erzeuge Dictionary \texttt{tls\_signal\_indices} mit Signalindizes je TLS aus \texttt{<connection>}-Elementen
      \ForAll{\texttt{junction}-Elemente im Netz}
        \State \texttt{tls\_id} $\gets$ ID der Junction
        \If{\texttt{tls\_id} in \texttt{tls\_signal\_indices}}
          \State \texttt{expected\_max} $\gets$ Länge der Signalindizes für dieses TLS
          \ForAll{\texttt{request}-Elemente in Junction}
            \State \texttt{index} $\gets$ Wert des \texttt{index}-Attributs
            \If{\texttt{index} $\geq$ \texttt{expected\_max}}
              \State Gib Warnung mit \texttt{tls\_id} und \texttt{index} aus
            \EndIf
          \EndFor
        \EndIf
      \EndFor
      \If{keine Warnungen ausgegeben}
        \State Gib Erfolgsmeldung aus
      \EndIf
    \EndFunction
    \end{algorithmic}
    \end{algorithm}


\newpage
\noindent
\textbf{Originalcode in Python (\texttt{check\_tls\_requests.py}):}
\begin{minted}[fontsize=\small, linenos, frame=lines, breaklines, tabsize=4]{python}
import xml.etree.ElementTree as ET

net_file = "karlsruhe.net.xml"
tree = ET.parse(net_file)
root = tree.getroot()

# Zähle für jedes TLS wie viele signal indices es gibt (controlled links)
tls_signal_indices = {}
for conn in root.findall("connection"):
    if "tl" in conn.attrib and "linkIndex" in conn.attrib:
        tls_id = conn.attrib["tl"]
        tls_signal_indices.setdefault(tls_id, set()).add(int(conn.attrib["linkIndex"]))

# Vergleiche mit den request-Elementen
print("Überprüfe request-Indizes gegen Signalindizes...\n")
any_issues = False
for junction in root.findall("junction"):
    tls_id = junction.attrib.get("id")
    requests = junction.findall("request")
    if tls_id in tls_signal_indices:
        expected_max = len(tls_signal_indices[tls_id])
        for req in requests:
            index = int(req.attrib["index"])
            if index >= expected_max:
                print(f"Junction '{tls_id}': request index {index} > max signal index {expected_max - 1}")
                any_issues = True

if not any_issues:
    print("Alle request-Indizes passen zu den TLS-Signalindizes!")
\end{minted}
\end{itemize}

\newpage
\paragraph{Automatische Reparaturwerkzeuge}

Die folgenden Programme wurden zur strukturellen Korrektur entwickelt:

\begin{itemize}
    \item \textbf{\texttt{fix\_requests.py}} entfernt überzählige \texttt{<request>}-Einträge und kürzt \texttt{state}-Strings in Phasen auf die zulässige Länge. Die Bereinigung erfolgt anhand der tatsächlichen Anzahl gesteuerter Signalverbindungen (\texttt{linkIndex}).

    \begin{algorithm}[H]
\caption{FixRequests – Bereinigung ungültiger \texttt{<request>}-Einträge und Anpassung der Phasen}
\begin{algorithmic}[1]
\Function{FixRequests}{net.xml}
  \State Lade XML-Baum mit Netzstruktur
  \State Initialisiere Dictionary \texttt{tls\_max\_index} für maximale Signalindices
  \ForAll{\texttt{connection}-Elemente}
    \If{TLS-ID und \texttt{linkIndex} vorhanden}
      \State Aktualisiere \texttt{tls\_max\_index[tl]} mit höchstem Index
    \EndIf
  \EndFor

  \ForAll{\texttt{junction}-Elemente}
    \State Hole TLS-ID
    \If{TLS nicht in \texttt{tls\_max\_index}}
      \State \textbf{continue}
    \EndIf
    \State Bestimme erlaubten Maximalindex (\texttt{max\_idx})
    \ForAll{\texttt{request}-Einträge}
      \If{Index $>$ \texttt{max\_idx}}
        \State Entferne ungültigen \texttt{request}
      \EndIf
    \EndFor

    \ForAll{\texttt{tlLogic}-Elemente mit passender TLS-ID}
      \ForAll{Phasen}
        \If{\texttt{state}-String ist zu lang}
          \State Kürze \texttt{state} auf \texttt{max\_idx + 1}
        \EndIf
      \EndFor
    \EndFor
  \EndFor

  \State Speichere modifizierte XML-Datei
  \State Gib Statistiken zu entfernten Requests und angepassten Phasen aus
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage
\noindent
\textbf{Originalcode in Python (\texttt{fix\_requests.py}):}
\begin{minted}[fontsize=\small, linenos, frame=lines, breaklines, tabsize=4]{python}
import xml.etree.ElementTree as ET

net_file = "karlsruhe.net.xml"
output_file = "karlsruhe_fixed_tls.net.xml"

tree = ET.parse(net_file)
root = tree.getroot()

# Finde maximal verwendete Signal-Indices pro TLS
tls_max_index = {}
for conn in root.findall("connection"):
    tl = conn.get("tl")
    idx = conn.get("linkIndex")
    if tl and idx:
        idx = int(idx)
        tls_max_index[tl] = max(tls_max_index.get(tl, -1), idx)

# Bereinigung
total_removed_requests = 0
total_adjusted_phases = 0
changed_tls = []

for junction in root.findall("junction"):
    tls_id = junction.get("id")
    if tls_id not in tls_max_index:
        continue

    max_idx = tls_max_index[tls_id]
    requests = list(junction.findall("request"))
    removed = 0

    for req in requests:
        req_idx = int(req.get("index"))
        if req_idx > max_idx:
            junction.remove(req)
            removed += 1

    if removed > 0:
        print(f"TLS '{tls_id}': {removed} ungültige <request>-Einträge entfernt.")
        total_removed_requests += removed
        changed_tls.append(tls_id)

    # Kürze zugehörige Phasen
    for tl in root.findall("tlLogic"):
        if tl.get("id") == tls_id:
            adjusted = 0
            for phase in tl.findall("phase"):
                state = phase.get("state")
                if len(state) > max_idx + 1:
                    old_len = len(state)
                    phase.set("state", state[:max_idx + 1])
                    adjusted += 1
            if adjusted > 0:
                print(f" TLS '{tls_id}': {adjusted} <phase>-Strings auf Länge {max_idx + 1} gekürzt.")
                total_adjusted_phases += adjusted
                if tls_id not in changed_tls:
                    changed_tls.append(tls_id)

# Speichern
tree.write(output_file, encoding="utf-8")
print("\n Reparatur abgeschlossen.")
print(f" Gesamt entfernte <request>-Einträge: {total_removed_requests}")
print(f" Gesamt angepasste <phase>-Einträge: {total_adjusted_phases}")
print(f" Betroffene TLS-IDs: {len(changed_tls)} Stück")
for tls in changed_tls:
    print(f"  - {tls}")
print(f"\n Bereinigte Datei gespeichert unter: {output_file}")
\end{minted}
\vspace{1cm}
    \item \textbf{\texttt{repair-net.py}} nutzt ein manuell gepflegtes Dictionary mit TLS-IDs und deren erwarteter Phasenlänge (Anzahl kontrollierter Verbindungen). Alle Phasen, deren Länge abweicht, werden automatisch gekürzt oder aufgefüllt.

    \begin{algorithm}[H]
\caption{RepairTLSStates – Korrektur der Phasenlängen anhand manuell gepflegter Referenz}
\begin{algorithmic}[1]
\Function{RepairTLSStates}{net.xml, referenz\_dictionary}
  \State Lade Netzstruktur aus \texttt{net.xml}
  \ForAll{\texttt{tlLogic}-Elemente im Netz}
    \State \texttt{tls\_id} $\gets$ ID des Ampelknotens
    \If{\texttt{tls\_id} nicht in referenz\_dictionary}
      \State \textbf{continue}
    \EndIf
    \State \texttt{correctLen} $\gets$ erwartete Zustandslänge aus Referenz
    \ForAll{Phasen des Knotens}
      \State \texttt{state} $\gets$ Zeichenkette der Phase
      \If{Länge(\texttt{state}) $\neq$ \texttt{correctLen}}
        \State Kürze oder ergänze \texttt{state} auf \texttt{correctLen}
        \State Markiere Netz als geändert
      \EndIf
    \EndFor
  \EndFor
  \If{Netz wurde geändert}
    \State Speichere bereinigte Netzdatei als \texttt{karlsruhe\_fixed.net.xml}
  \Else
    \State Gib Hinweis: Alle Phasen bereits korrekt
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\newpage
\noindent
\textbf{Originalcode in Python (\texttt{repair\_net.py}):}
\begin{minted}[fontsize=\small, linenos, frame=lines, breaklines, tabsize=4]{python}
from xml.etree import ElementTree as ET

# Manuell gepflegte Dictionary mit {TLS-ID: Anzahl controlledLinks}
controlled_links = {
    "1720933516": 6,
    "3538953167": 2,
    "3664415977": 10,
    "cluster_14795187_1720919996_2670370290_2670370291": 11,
    "cluster_14795804_55474925_6655074904_765746891_#1more": 49,
    "cluster_15431428_1719671850_1720917935": 20,
    "cluster_1590912233_3664415976_5083348337_5083348350": 11,
    "cluster_1692973685_1692973722_1718084055_1718084058_#11more": 36,
    "cluster_1729190097_3687504105": 8,
    "cluster_1744031943_5131521735": 10,
    "joinedS_1623835169_cluster_1137679587_1626739216_1728272870_1728272909_#17more": 33,
    "joinedS_309108716_cluster_11001804363_1125509937_12515596172_1784859792_#5more": 14,
    "joinedS_5092985445_cluster_1590912226_2911376263": 10,
    # ggf. mehr hinzufügen
}

tree = ET.parse("karlsruhe.net.xml")
root = tree.getroot()
changed = False

for logic in root.findall("tlLogic"):
    tl_id = logic.attrib["id"]
    if tl_id not in controlled_links:
        continue

    correct_len = controlled_links[tl_id]
    for phase in logic.findall("phase"):
        state = phase.attrib["state"]
        if len(state) != correct_len:
            new_state = state[:correct_len].ljust(correct_len, 'r')
            print(f" Fixing {tl_id}: {len(state)} → {correct_len}")
            phase.attrib["state"] = new_state
            changed = True

if changed:
    tree.write("karlsruhe_fixed.net.xml")
    print(" Bereinigte Datei gespeichert: karlsruhe_fixed.net.xml")
else:
    print(" Alle Phasen bereits korrekt.")

\end{minted}

    \newpage
    \item \textbf{\texttt{statecheck.py}} gibt eine Liste aller TLS-Phasen mit ungewöhnlichen Längen aus. Dieses Tool wurde verwendet, um bei vereinheitlichten Netzen auf eine Ziel-Zustandslänge zu prüfen.

    \begin{algorithm}[H]
\caption{StateCheck – Prüfung auf einheitliche Phasenlängen}
\begin{algorithmic}[1]
\Function{StateCheck}{net.xml}
  \State Lade XML-Baum aus der Netzdatei
  \ForAll{\texttt{tlLogic}-Elemente im Netz}
    \State \texttt{tl\_id} $\gets$ ID des aktuellen TLS
    \ForAll{Phasen $i$ in \texttt{tlLogic}}
      \State \texttt{state} $\gets$ Zustand der Phase
      \If{\texttt{len(state)} $\neq$ 57}
        \State Gib Warnung mit \texttt{tl\_id}, Phasenindex und tatsächlicher Länge aus
      \EndIf
    \EndFor
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\noindent
\textbf{Originalcode in Python (\texttt{statecheck.py}):}
\begin{minted}[fontsize=\small, linenos, frame=lines, breaklines, tabsize=4]{python}
from xml.etree import ElementTree as ET

tree = ET.parse("karlsruhe.net.xml")
root = tree.getroot()

for logic in root.findall("tlLogic"):
    tl_id = logic.attrib["id"]
    for i, phase in enumerate(logic.findall("phase")):
        state = phase.attrib["state"]
        if len(state) != 57:
            print(f" Phase {i} of TLS '{tl_id}' has length {len(state)}")
\end{minted}

\end{itemize}

\newpage
\paragraph{Gültigkeitsprüfung für SUMO-RL}

Zur Vorbereitung des Trainings wurden weitere Programme zur Identifikation funktionaler TLS entwickelt:

\begin{itemize}
    \item \textbf{\texttt{find\_valid\_tls.py}} iteriert über alle TLS im Netz und testet jede einzeln in einem minimalen \texttt{sumo-rl}-Lauf. TLS, bei denen die Umgebung erfolgreich initialisiert werden kann, gelten als kompatibel.

    \begin{algorithm}[H]
\caption{FindValidTLS – Gültigkeitsprüfung aller TLS im Netz}
\begin{algorithmic}[1]
\Function{TestTLS}{\texttt{tls\_id}}
  \State Initialisiere \texttt{SumoEnvironment}
  \State Setze \texttt{ts\_ids} auf \texttt{[tls\_id]}
  \State Versuche: \texttt{env.reset()}
  \If{kein Fehler}
    \State \texttt{env.close()}
    \State \Return \texttt{True}
  \Else
    \State Gib Fehlermeldung aus
    \State \Return \texttt{False}
  \EndIf
\EndFunction
\vspace{0.5em}
\State Initialisiere leere Liste \texttt{all\_tls}
\State Versuche: Umgebung mit \texttt{SumoEnvironment} zu starten
\If{erfolgreich}
  \State Lese alle \texttt{ts\_ids}
  \State Schließe Umgebung
\Else
  \State Gib Fehler aus
\EndIf
\vspace{0.5em}
\State Initialisiere leere Liste \texttt{valid\_tls}
\ForAll{\texttt{tls\_id} in \texttt{all\_tls}}
  \If{ \Call{TestTLS}{\texttt{tls\_id}} }
    \State Füge \texttt{tls\_id} zu \texttt{valid\_tls} hinzu
  \EndIf
\EndFor
\State Gib alle gültigen TLS aus
\end{algorithmic}
\end{algorithm}

\newpage
\noindent
\textbf{Originalcode in Python (\texttt{find\_valid\_tls.py}):}
\begin{minted}[fontsize=\small, linenos, frame=lines, breaklines, tabsize=4]{python}
from sumo_rl import SumoEnvironment
import traci
import os

def test_tls(tls_id):
    try:
        env = SumoEnvironment(
            net_file="karlsruhe.net.xml",
            route_file="karlsruhe.rou.xml",
            use_gui=False,
            single_agent=True
        )
        env.ts_ids = [tls_id]
        env.reset()
        env.close()
        return True
    except Exception as e:
        print(f" TLS {tls_id} nicht gültig: {e}")
        return False

# Alle TLS holen
try:
    env = SumoEnvironment(
        net_file="karlsruhe.net.xml",
        route_file="karlsruhe.rou.xml",
        use_gui=False,
        single_agent=True
    )
    all_tls = env.ts_ids
    env.close()
except Exception as e:
    print(" Konnte TLS nicht auslesen:", e)
    all_tls = []

print(f" Teste {len(all_tls)} TLS auf Gültigkeit...\n")
valid_tls = []

for tls_id in all_tls:
    if test_tls(tls_id):
        valid_tls.append(tls_id)

print("\n Gültige TLS:")
print(valid_tls)
\end{minted}
    
\end{itemize}

\subsubsection{Auswahl eines bereinigten Netzes}

Nach mehrfacher Iteration und Debugging wurde ein final bereinigtes Netz erzeugt: \texttt{karlsruhe.net.xml}. Dieses enthält ausschließlich überprüfte TLS mit konsistenten Phasenlängen und steuerbaren Verbindungen. Es bildet die Grundlage für alle nachfolgenden Reinforcement-Learning-Experimente.

\subsubsection{Vorteil des automatisierten Workflows}

Die entwickelte Toolchain ermöglicht:

\begin{itemize}
    \item eine strukturierte Diagnose typischer OSM-bedingter Netzprobleme,
    \item reproduzierbare Netzreparaturen ohne manuelles Editieren in \texttt{netedit},
    \item automatisierte Validierung vor dem Training in \texttt{sumo-rl},
    \item gezielte Selektion steuerbarer TLS für das Experiment.
\end{itemize}

Der Einsatz dieser Werkzeuge war unerlässlich, um ein funktionales, kompatibles und robusteres Simulationsnetz auf Basis realer OSM-Daten zu etablieren.


\subsection{Implementierung mit sumo-rl}
\subsection{Trainingsstrategie und Hyperparameterwahl}

\section{Evaluation und Ergebnisse}
\subsection{Vergleichsszenarien}
\subsection{Leistungsmetriken}
\subsection{Simulationsergebnisse}
\subsection{Interpretation und Diskussion der Ergebnisse}

\section{Herausforderungen und Limitationen}
\subsection{Technische und methodische Hürden}
\subsection{Repräsentativität und Qualität der Daten}
\subsection{Generalisierbarkeit der Ergebnisse}

\section{Fazit und Ausblick}
\subsection{Zusammenfassung der wichtigsten Erkenntnisse}
\subsection{Mögliche Weiterentwicklungen}
\subsection{Relevanz für reale Verkehrsplanung}

\appendix
\section{Anhang}
\subsection{Code-Ausschnitte}
\subsection{Parameterlisten}
\subsection{Zusätzliche Auswertungen}
\subsection{Korrespondenz mit Behörden}

\newpage
\begin{thebibliography}{12}
\bibitem{bast}
Bundesanstalt für Straßenwesen (BASt). \url{https://www.bast.de}, Zugriff am 21.05.2025.

\bibitem{chu2020}
Chu, T.; Wang, J.; He, R.; Xia, Y. (2020):  
\textit{Multi-Agent Deep Reinforcement Learning for Large-Scale Traffic Signal Control}.  
In: IEEE Transactions on Intelligent Transportation Systems.  
DOI: \url{https://doi.org/10.1109/TITS.2020.3014863}

\bibitem{googlemaps}
Google Maps Traffic API. 
\href{https://developers.google.com/maps/documentation/traffic}, Zugriff am 21.05.2025.

\bibitem{josm}
JOSM – Java OpenStreetMap Editor.  
\url{https://josm.openstreetmap.de}, Zugriff am 21.05.2025.

\bibitem{mobidata}
MobiData BW – Mobilitätsdatenplattform Baden-Württemberg. 
\url{https://www.mobidata-bw.de}, Zugriff am 21.05.2025.

\bibitem{mobidata_karte}
MobiData BW: Karte der Dauerzählstellen im Straßenverkehr,  
\url{https://mobidata-bw.de/dataset/karte_strassenverkehrszaehlung}, Zugriff am 21.05.2025.

\bibitem{mobidata_stunden}
MobiData BW: Stundenwerte an Dauerzählstellen (Straßenverkehr),  
\url{https://mobidata-bw.de/dataset/stundenwerte_dauerzaehlstellen}, Zugriff am 21.05.2025.

\bibitem{osm}
OpenStreetMap. 
\url{https://www.openstreetmap.org}, Zugriff am 21.05.2025.

\bibitem{osm-export}
OpenStreetMap Wiki: Export.  
\url{https://wiki.openstreetmap.org/w/index.php?title=Export&oldid=2822860}, Zugriff am 21.06.2025.

\bibitem{sumo-doc}
SUMO Dokumentation. 
\url{https://sumo.dlr.de}, Zugriff am 21.05.2025.

\bibitem{sumo-rl}
sumo-rl: Reinforcement Learning Environments for Traffic Signal Control in SUMO.  
GitHub Repository.  
\url{https://github.com/LucasAlegre/sumo-rl}, Zugriff am 21.05.2025.

\bibitem{sumo-tools}
SUMO Toolchain: Netzwerk- und Routengeneratoren.  
\url{https://sumo.dlr.de/docs/Tools.html}, Zugriff am 21.05.2025.

\bibitem{svzbw}
Straßenverkehrszentrale Baden-Württemberg. 
\url{https://www.svz-bw.de}, Zugriff am 21.05.2025.

\bibitem{tomtom}
TomTom Traffic API.
\url{https://developer.tomtom.com/traffic-api}, Zugriff am 21.05.2025.

\bibitem{wei2019}
Wei, H.; Zheng, G.; Yao, H.; Li, Z. (2019):  
\textit{A Deep Reinforcement Learning Approach for Traffic Signal Control in Vehicular Networks}.  
In: Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery \& Data Mining, S. 2496–2505.  
DOI: 
\url{https://doi.org/10.1145/3292500.3330662}

\bibitem{zheng2019}
Zheng, G.; Ye, H.; Zhang, H.; Wu, K.; Li, Z. (2019):  
\textit{Learning Phase Competition for Traffic Signal Control}.  
arXiv preprint.  
\url{https://arxiv.org/abs/1907.09076}

\end{thebibliography}

\end{document}
